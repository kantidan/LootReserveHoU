<Ui xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns="http://www.blizzard.com/wow/ui/">
	<Script file="ServerWindow.lua" />
	<Button name="LootReserveHoUServerWindowTabTemplate" parentArray="Tabs" virtual="true">
		<Size>
			<AbsDimension x="10" y="32" />
		</Size>
		<Layers>
			<Layer level="BACKGROUND">
				<Texture parentKey="LeftDisabled" file="Interface\PaperDollInfoFrame\UI-Character-ActiveTab">
					<Size x="20" y="32" />
					<Anchors>
						<Anchor point="TOPLEFT" x="0" y="5" />
					</Anchors>
					<TexCoords left="0" right="0.15625" top="0" bottom="1" />
				</Texture>
				<Texture parentKey="MiddleDisabled" file="Interface\PaperDollInfoFrame\UI-Character-ActiveTab">
					<Size x="88" y="32" />
					<Anchors>
						<Anchor point="LEFT" relativeKey="$parent.LeftDisabled" relativePoint="RIGHT" />
					</Anchors>
					<TexCoords left="0.15625" right="0.84375" top="0" bottom="1" />
				</Texture>
				<Texture parentKey="RightDisabled" file="Interface\PaperDollInfoFrame\UI-Character-ActiveTab">
					<Size x="20" y="32" />
					<Anchors>
						<Anchor point="LEFT" relativeKey="$parent.MiddleDisabled" relativePoint="RIGHT" />
					</Anchors>
					<TexCoords left="0.84375" right="1" top="0" bottom="1" />
				</Texture>
				<Texture parentKey="Left" file="Interface\PaperDollInfoFrame\UI-Character-InActiveTab">
					<Size x="20" y="32" />
					<Anchors>
						<Anchor point="TOPLEFT" x="0" y="1" />
					</Anchors>
					<TexCoords left="0" right="0.15625" top="0" bottom="1" />
				</Texture>
				<Texture parentKey="Middle" file="Interface\PaperDollInfoFrame\UI-Character-InActiveTab">
					<Size x="88" y="32" />
					<Anchors>
						<Anchor point="LEFT" relativeKey="$parent.Left" relativePoint="RIGHT" />
					</Anchors>
					<TexCoords left="0.15625" right="0.84375" top="0" bottom="1" />
				</Texture>
				<Texture parentKey="Right" file="Interface\PaperDollInfoFrame\UI-Character-InActiveTab">
					<Size x="20" y="32" />
					<Anchors>
						<Anchor point="LEFT" relativeKey="$parent.Middle" relativePoint="RIGHT" />
					</Anchors>
					<TexCoords left="0.84375" right="1" top="0" bottom="1" />
				</Texture>
			</Layer>
		</Layers>
		<Scripts>
			<OnLoad>
				self.selectedTextY = 4;
				self:SetFrameLevel(self:GetFrameLevel() + 4);
				self:RegisterEvent("DISPLAY_SIZE_CHANGED");
			</OnLoad>
			<OnEvent>
				if (self:IsVisible()) then
					PanelTemplates_TabResize(self, 0, nil, 36, self:GetParent().maxTabWidth or 88);
				end
			</OnEvent>
			<OnShow>
				PanelTemplates_TabResize(self, 0);
			</OnShow>
			<OnClick>
				LootReserveHoU.Server:OnWindowTabClick(self);
			</OnClick>
		</Scripts>
		<HighlightTexture parentKey="HighlightTexture" file="Interface\PaperDollInfoFrame\UI-Character-Tab-RealHighlight" alphaMode="ADD">
			<Anchors>
				<Anchor point="TOPLEFT">
					<Offset>
						<AbsDimension x="3" y="5"/>
					</Offset>
				</Anchor>
				<Anchor point="BOTTOMRIGHT">
					<Offset>
						<AbsDimension x="-3" y="0"/>
					</Offset>
				</Anchor>
			</Anchors>
		</HighlightTexture>
		<ButtonText parentKey="Text">
			<Size x="0" y="10" />
			<Anchors>
				<Anchor point="CENTER" x="0" y="2" />
			</Anchors>
		</ButtonText>
		<NormalFont style="GameFontNormalSmall" />
		<HighlightFont style="GameFontHighlightSmall" />
		<DisabledFont style="GameFontHighlightSmall" />
	</Button>
	<Button name="LootReserveHoUReserveListPlayerTemplate" virtual="true">
		<Size y="16" />
		<Layers>
			<Layer>
				<Texture parentKey="GreenHighlight" file="Interface\QUESTFRAME\UI-QuestTitleHighlight" alphaMode="ADD" alpha="0.5">
					<Anchors>
						<Anchor point="TOPLEFT" x="16" />
						<Anchor point="BOTTOMRIGHT" />
					</Anchors>
					<Color r="0" g="1" b="0" />
				</Texture>
			</Layer>
			<Layer level="OVERLAY">
				<FontString parentKey="Roll" inherits="GameFontWhiteSmall" justifyH="CENTER" wordwrap="false">
					<Anchors>
						<Anchor point="TOPLEFT" relativePoint="TOPRIGHT" x="-32" />
						<Anchor point="BOTTOMRIGHT" />
					</Anchors>
				</FontString>
			</Layer>
		</Layers>
		<Frames>
			<Frame parentKey="RedHighlight" >
				<Anchors>
					<Anchor point="TOPLEFT" />
					<Anchor point="BOTTOMRIGHT" />
				</Anchors>
				<Layers>
					<Layer>
						<Texture parentKey="RedHighlightTexture" file="Interface\QUESTFRAME\UI-QuestTitleHighlight" alphaMode="ADD" alpha="0.5">
							<Anchors>
								<Anchor point="TOPLEFT" x="16" />
								<Anchor point="BOTTOMRIGHT" />
							</Anchors>
							<Color r="1" g="0.5" b="0" />
						</Texture>
					</Layer>
				</Layers>
				<Color r="1" g="0.5" b="0" />
				<Scripts>
					<OnUpdate>
						local hovered = self:IsMouseOver();
						if self.hovered ~= hovered or not GameTooltip:IsShown() then
							self.hovered = hovered;
							if hovered then
								GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
								GameTooltip:SetText(self.title);
								for _, line in ipairs(self.text or {}) do
									GameTooltip:AddLine(line, HIGHLIGHT_FONT_COLOR.r, HIGHLIGHT_FONT_COLOR.g, HIGHLIGHT_FONT_COLOR.b, 1, 1);
								end
								GameTooltip:Show()
							elseif GameTooltip:GetOwner() == self then
								GameTooltip:Hide()
							end
						end
					</OnUpdate>
				</Scripts>
			</Frame>
			<Button parentKey="ButtonDelete" hidden="true">
				<Size x="12" y="12"/>
				<Anchors>
					<Anchor point="TOPLEFT" x="2" y="-2" />
				</Anchors>
				<Scripts>
					<OnClick>
						local player = self:GetParent().Player;
						local rollNumber = self:GetParent().RollNumber;
						local frame = self:GetParent():GetParent():GetParent();
						local data = { Player = player, RollNumber = rollNumber, Item = frame.Item };
						local popup = "LootReserveHoU_CONFIRM_FORCED_CANCEL_RESERVE";
						if frame.Roll then
							popup = "LootReserveHoU_CONFIRM_FORCED_CANCEL_ROLL";
						end
						StaticPopup_Show(popup, LootReserveHoU:ColoredPlayer(player), frame.Link, data);
					</OnClick>
				</Scripts>
				<NormalTexture file="Interface\Buttons\UI-GroupLoot-Pass-Up" alpha="0.5"/>
				<HighlightTexture file="Interface\Buttons\UI-GroupLoot-Pass-Up" alpha="0.5" alphaMode="ADD"/>
				<PushedTexture file="Interface\Buttons\UI-GroupLoot-Pass-Down" alpha="0.5"/>
			</Button>
			<Button parentKey="ButtonReroll" hidden="true">
				<Size x="12" y="12"/>
				<Anchors>
					<Anchor point="TOPLEFT" x="2" y="-2" />
				</Anchors>
				<Scripts>
					<OnClick>
						if LootReserveHoU.Server.RequestedRoll and LootReserveHoU.Server.RequestedRoll.RaidRoll then
							LootReserveHoU.Server:DeleteRoll(self:GetParent().Player, self:GetParent().RollNumber, self:GetParent():GetParent():GetParent().Item);
						end
					</OnClick>
				</Scripts>
				<NormalTexture file="Interface\Buttons\UI-RefreshButton" />
				<HighlightTexture file="Interface\Buttons\UI-RefreshButton" alpha="0.5" alphaMode="ADD" />
				<PushedTexture file="Interface\Buttons\UI-RefreshButton" alpha="0.5" />
			</Button>
			<Frame parentKey="Name" inherits="LootReserveHoUTextWithButtonsTemplate">
				<KeyValues>
					<KeyValue key="font" value="GameFontWhiteSmall" type="global" />
					<KeyValue key="textMargin" value="2" type="number" />
				</KeyValues>
				<Anchors>
					<Anchor point="TOPLEFT" x="16" />
					<Anchor point="BOTTOMRIGHT" relativeKey="$parent.Roll" relativePoint="BOTTOMLEFT" />
				</Anchors>
				<Frames>
					<Button parentKey="WonRolls" parentArray="Buttons" hidden="true">
						<Size x="12" y="12" />
						<Scripts>
							<OnLoad>
								self.UpdateTooltip = function(self)
									local player = self:GetParent():GetParent().Player;
									local won = LootReserveHoU.Server.CurrentSession and LootReserveHoU.Server.CurrentSession.Members[player] and LootReserveHoU.Server.CurrentSession.Members[player].WonRolls;
									if won then
										local missing = { };
										GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
										GameTooltip:SetText("Won in the Current Session");
										local width = 0;
										for i, roll in ipairs(won) do
											local name, link, texture = roll.Item:GetNameLinkTexture();
											if not link then
												table.insert(missing, roll.Item);
											end

											local phaseText;
											local phaseColor;
											if roll.Phase == LootReserveHoU.Constants.WonRollPhase.Reserve then
												phaseText = "Reserved";
												phaseColor = NORMAL_FONT_COLOR;
											elseif roll.Phase == LootReserveHoU.Constants.WonRollPhase.RaidRoll then
												phaseText = "Raid-Roll";
												phaseColor = GRAY_FONT_COLOR;
											elseif type(roll.Phase) == "string" then
												phaseText = roll.Phase;
												phaseColor = GREEN_FONT_COLOR;
											else
												phaseText = "Custom Roll";
												phaseColor = HIGHLIGHT_FONT_COLOR;
											end

											local timeText;
											local age = time() - roll.Time;
											if age >= 3600 then
												timeText = format("%d |4hour:hours; %d |4min:mins; ago", math.floor(age / 3600), math.floor((age % 3600) / 60));
											elseif age >= 60 then
												timeText = format("%d |4min:mins; ago", math.floor(age / 60));
											else
												timeText = "&lt;1 min ago";
											end

											GameTooltip:AddDoubleLine(format("|T%d:0|t %s|cFF808080 (%s)|r", texture, (link or name or "|cFFFF4000Loading...|r"):gsub("[%[%]]", ""), timeText), phaseText, HIGHLIGHT_FONT_COLOR.r, HIGHLIGHT_FONT_COLOR.g, HIGHLIGHT_FONT_COLOR.b, phaseColor.r, phaseColor.g, phaseColor.b);
										end
										GameTooltip:Show();

										if #missing > 0 then
											LootReserveHoU.ItemCache:OnCache(missing, function()
												if GameTooltip:IsOwned(self) then
													self:UpdateTooltip();
												end
											end);
										end
									end
								end
							</OnLoad>
							<OnEnter>
								self:UpdateTooltip();
							</OnEnter>
							<OnLeave function="GameTooltip_Hide" />
						</Scripts>
						<NormalTexture file="Interface\GossipFrame\VendorGossipIcon" alpha="0.5" />
						<HighlightTexture file="Interface\GossipFrame\VendorGossipIcon" alpha="0.75" alphaMode="ADD" />
					</Button>
					<Button parentKey="RecentChat" parentArray="Buttons" hidden="true">
						<Size x="12" y="12" />
						<Scripts>
							<OnEnter>
								local player = self:GetParent():GetParent().Player;
								local frame = self:GetParent():GetParent():GetParent():GetParent();
								if frame.Roll and frame.Roll.Chat and frame.Roll.Chat[player] then
									GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
									GameTooltip:SetText("Recent Chat");
									local width = 0;
									local expectedRolls = #frame.Roll.Players[player];
									local actualRolls = 0;
									for i, data in ipairs(frame.Roll.Chat[player]) do
										local time, type, text = strsplit("|", data, 3);
										time = format("|cFF808080[%s]|r", date("%X", tonumber(time)));
										local info = ChatTypeInfo[type or ""] or ChatTypeInfo["SYSTEM"];
										if type == "SYSTEM" then
											text = format("%s %s", time, text);
											if text:find("%(%d+%-%d+%)") then
												actualRolls = actualRolls + 1;
											  if actualRolls > expectedRolls or not text:find("%(1%-100%)") then
												  info = ChatTypeInfo["RESTRICTED"]
												end
											end
										elseif type == "EMOTE" then
											text = format("%s %s %s", time, player, text);
										else
											text = format("%s [%s]: %s", time, LootReserveHoU:ColoredPlayer(player, frame.Roll.Chat[player].Class), text);
										end
										GameTooltip:AddLine(text, info.r, info.g, info.b, 1, 1);
										local line = _G[GameTooltip:GetName() .. "TextLeft" .. (i + 1)];
										if line and line:GetText() == text then
											width = math.max(width, line:GetUnboundedStringWidth());
										end
									end
									GameTooltip:SetMinimumWidth(math.min(width, 400));
									GameTooltip:Show();
								end
							</OnEnter>
							<OnLeave function="GameTooltip_Hide" />
						</Scripts>
						<NormalTexture file="Interface\ChatFrame\UI-ChatWhisperIcon" alpha="0.25" />
						<HighlightTexture file="Interface\ChatFrame\UI-ChatWhisperIcon" alpha="0.5" alphaMode="ADD" />
					</Button>
					<Button parentKey="ButtonWhisper" parentArray="Buttons" hidden="true">
						<Anchors>
							<Anchor point="TOP" />
							<Anchor point="BOTTOM" />
						</Anchors>
						<ButtonText parentKey="Text" inherits="GameFontNormal" text=" /w " setAllPoints="true" />
						<Scripts>
							<OnLoad>
								local info = ChatTypeInfo["WHISPER"];
								self.Text:SetTextColor(info.r, info.g, info.b);
								self:SetWidth(self.Text:GetStringWidth());
							</OnLoad>
							<OnClick>
								ChatFrame_SendTell(self:GetParent():GetParent().Player);
							</OnClick>
						</Scripts>
					</Button>
				</Frames>
			</Frame>
		</Frames>
		<Scripts>
			<OnUpdate>
				if self:IsProtected() and InCombatLockdown() then return; end
				local frame = self:GetParent():GetParent();
				local hovered = self:IsMouseOver();
				if self.hovered ~= hovered then
					self.hovered = hovered;
					if not hovered or self:GetParent():GetParent().Historical then
						self.Name.ButtonWhisper:SetShown(hovered);
						self.ButtonDelete:Hide();
						self.ButtonReroll:Hide();
					elseif not frame.Roll then
						self.Name.ButtonWhisper:Show();
						self.ButtonDelete:Show();
						self.ButtonReroll:Hide();
					else
						local roll = frame.Roll.Players[self.Player] and frame.Roll.Players[self.Player][self.RollNumber];
						local isRaidRoll = frame.Roll.RaidRoll;
						self.Name.ButtonWhisper:Show();
						self.ButtonDelete:SetShown(roll and roll > LootReserveHoU.Constants.RollType.NotRolled and not isRaidRoll);
						self.ButtonReroll:SetShown(roll and roll > LootReserveHoU.Constants.RollType.NotRolled and     isRaidRoll);
					end
				end
			</OnUpdate>
		</Scripts>
	</Button>
	<Button name="LootReserveHoUReserveListPlayerSecureTemplate" inherits="LootReserveHoUReserveListPlayerTemplate, SecureUnitButtonTemplate" virtual="true">
		<Layers>
			<Layer level="HIGHLIGHT">
				<Texture file="Interface\QUESTFRAME\UI-QuestTitleHighlight" alphaMode="ADD" alpha="0.25">
					<Anchors>
						<Anchor point="TOPLEFT" x="16" />
						<Anchor point="BOTTOMRIGHT" />
					</Anchors>
					<Color r="1" g="1" b="1" />
				</Texture>
			</Layer>
		</Layers>
		<Frames>
			<Frame parentKey="DropDown" inherits="UIDropDownMenuTemplate" hidden="true" />
		</Frames>
		<Scripts>
			<OnLoad>
				self:RegisterForClicks("LeftButtonUp", "RightButtonUp");
				self.init = function(self)
					self.init = nil;
					SecureUnitButton_OnLoad(self, nil, function()
						local unit = self:GetAttribute("unit");
						if unit then
							UIDropDownMenu_Initialize(self.DropDown, function(self) UnitPopup_ShowMenu(self, "PLAYER", unit); end, "MENU");
							ToggleDropDownMenu(nil, nil, self.DropDown, "cursor", 0, 0);
						end
					end);
				end
			</OnLoad>
		</Scripts>
	</Button>
	<Frame name="LootReserveHoUReserveListTemplate" virtual="true" enableMouse="true" inherits="LootReserveHoUBackdropTemplate">
		<KeyValues>
			<KeyValue key="backdropInfo" value="LootReserveHoU_BACKDROP_BLACK_4" type="global" />
		</KeyValues>
		<Size y="200" />
		<Backdrop bgFile="Interface\DialogFrame\UI-DialogBox-Background" edgeFile="Interface\Tooltips\UI-Tooltip-Border">
			<BackgroundInsets left="5" right="5" top="5" bottom="5" />
			<EdgeSize val="16" />
			<BorderColor r="1" g="1" b="1" a="1" />
		</Backdrop>
		<Frames>
			<Frame parentKey="Menu" inherits="UIDropDownMenuTemplate" hidden="true" />
			<Button parentKey="RequestRollButton" frameLevel="101">
				<Size x="32" y="32" />
				<Anchors>
					<Anchor point="TOPRIGHT" x="-6" y="-6" />
				</Anchors>
				<Layers>
					<Layer level="OVERLAY">
						<Texture parentKey="CancelIcon" file="Interface\Buttons\UI-GroupLoot-Pass-Up">
							<Size x="16" y="16" />
							<Anchors>
								<Anchor point="BOTTOMRIGHT" />
							</Anchors>
						</Texture>
					</Layer>
				</Layers>
				<Scripts>
					<OnLoad>
						self.UpdateTooltip = function(self)
							GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
							if self:GetParent().Historical then
								
								local oldRoll = self:GetParent().Roll;
								local Roll, doRequestedRoll = LootReserveHoU.Server:GetContinueRollData(oldRoll);
								
								if doRequestedRoll then
									GameTooltip:SetText("Continue Roll");
									GameTooltip:AddLine(format("Continue this roll%s.%s", oldRoll.Winners and format(", removing the %d |4winner:winners;", #oldRoll.Winners) or "", Roll.Phases and ("|nThe item will roll for " .. Roll.Phases[1] .. ".") or ""), HIGHLIGHT_FONT_COLOR.r, HIGHLIGHT_FONT_COLOR.g, HIGHLIGHT_FONT_COLOR.b, 1, 1);
								else
									GameTooltip:SetText("Prepare Roll");
									GameTooltip:AddLine("Prepare a roll for this item", HIGHLIGHT_FONT_COLOR.r, HIGHLIGHT_FONT_COLOR.g, HIGHLIGHT_FONT_COLOR.b, 1, 1);
								end
							else
								local rollingThisItem = LootReserveHoU.Server:IsRolling(self:GetParent().Item);
								GameTooltip:SetText(rollingThisItem and "End Roll" or "Request Roll");
								GameTooltip:AddLine(rollingThisItem and "Stop accepting rolls for this item." or "Ask all players who reserved this item to /roll on it.", HIGHLIGHT_FONT_COLOR.r, HIGHLIGHT_FONT_COLOR.g, HIGHLIGHT_FONT_COLOR.b, 1, 1);
							end
							GameTooltip:Show();
						end
					</OnLoad>
					<OnClick>
						if not LootReserveHoU.Server.RequestedRoll and self:GetParent().Historical then
							LootReserveHoU.Server:ContinueRoll(self:GetParent().Roll);
						elseif LootReserveHoU.Server:IsRolling(self:GetParent().Item) then
							local roll, players = LootReserveHoU.Server:GetWinningRollAndPlayers();
							if players then
								for i = 1, #players do
									players[i] = LootReserveHoU:ColoredPlayer(players[i]);
								end
							end
							local item = self:GetParent().Item;
							local disenchanter = LootReserveHoU.Server:GetDisenchanter();
							local menu =
							{
								{ text = "End Roll", isTitle = true },
								{ text = players and format("Announce %d |4Winner:Winners; (%s)", #players, strjoin(", ", unpack(players))) or "Announce Winner", disabled = not players or #players == 0, func = function() LootReserveHoU.Server:FinishRollRequest(self:GetParent().Item); end },
								{ text = "End Silently", func = function() LootReserveHoU.Server:FinishRollRequest(self:GetParent().Item, nil, true); end },
								{ text = "Cancel Roll", func = function() LootReserveHoU.Server:CancelRollRequest(self:GetParent().Item, nil, true); end },
								LootReserveHoU:MakeMenuSeparator(),
								{ text = "Cancel" },
							};
							if players then
								
								local recentLootCount = LootReserveHoU:TableCount(LootReserveHoU.Server.RecentLoot, self:GetParent().Item);
								if #players > 1 then
									table.insert(menu, 2, { text = format("Resolve Tie Roll: |cFF00FF00%d|r (%s)", roll, strjoin(", ", unpack(players))), func = function() LootReserveHoU.Server:ResolveRollTie(self:GetParent().Item); end });
								end
								if recentLootCount > #players and (not self:GetParent().Roll.Custom or self:GetParent().Roll.Phases and #self:GetParent().Roll.Phases > 1) then
									table.insert(menu, 2, { text = players and format("Announce %d |4Winner:Winners; (%s) and continue", #players, strjoin(", ", unpack(players))) or "Announce Winner", disabled = not players or #players == 0, func = function() LootReserveHoU.Server:FinishRollRequest(self:GetParent().Item, nil, nil, true); LootReserveHoU.Server:ContinueRoll(LootReserveHoU.Server.RollHistory[#LootReserveHoU.Server.RollHistory]) end });
								end
							elseif LootReserveHoU.Server.RequestedRoll.Phases and #LootReserveHoU.Server.RequestedRoll.Phases > 1 then
								menu[3] =
								{
									text = format("Advance to |cFF00FF00%s|r", LootReserveHoU.Server.RequestedRoll.Phases[2]),
									func = function() LootReserveHoU.Server:AdvanceRollPhase(self:GetParent().Item); end,
								};
							else
								table.insert(menu, 3, {
									text = format(disenchanter and "Send to Disenchanter: %s" or "Send to Disenchanter", disenchanter and LootReserveHoU:ColoredPlayer(disenchanter)),
									disabled = not disenchanter,
									func = function() LootReserveHoU.Server:FinishRollRequest(self:GetParent().Item, nil, true); LootReserveHoU.Server:RecordDisenchant(item, disenchanter); end,
								});
							end
							if LootReserveHoU:IsLootingItem(self:GetParent().Item) then
								table.insert(menu, #menu - 1, LootReserveHoU:MakeMenuSeparator());
								table.insert(menu, #menu - 1,
								{
									text = "Master Loot to Winner",
									tooltipText = "Automatically masterloot the item away to the roll winner once they're announced.",
									checked = LootReserveHoU.Server.Settings.RollMasterLoot,
									func = function(_, _, _, checked) LootReserveHoU.Server.Settings.RollMasterLoot = checked; end,
								});
							end
							local separator = false;
							if LootReserveHoU.Server.RequestedRoll.Duration and LootReserveHoU.Server.RequestedRoll.Duration ~= 0 then
								if not separator then
									table.insert(menu, #menu - 1, LootReserveHoU:MakeMenuSeparator());
									separator = true;
								end
								if not players and LootReserveHoU.Server.RequestedRoll.Phases and #LootReserveHoU.Server.RequestedRoll.Phases > 1 then
									table.insert(menu, #menu - 1,
									{
										text = "Advance Automatically",
										tooltipText = "Advance to the next stage when the timer expires if nobody rolled.",
										checked = LootReserveHoU.Server.Settings.RollAdvanceOnExpire,
										func = function(_, _, _, checked) LootReserveHoU.Server.Settings.RollAdvanceOnExpire = checked; end,
									});
								end
								table.insert(menu, #menu - 1,
								{
									text = "End Automatically",
									tooltipText = "Announce the winner and end the roll when the timer expires.",
									checked = LootReserveHoU.Server.Settings.RollFinishOnExpire,
									func = function(_, _, _, checked) LootReserveHoU.Server.Settings.RollFinishOnExpire = checked; end,
								});
							end
							if not LootReserveHoU.Server.RequestedRoll.Custom and not LootReserveHoU.Server.RequestedRoll.RaidRoll then
								if not separator then
									table.insert(menu, #menu - 1, LootReserveHoU:MakeMenuSeparator());
									separator = true;
								end
								table.insert(menu, #menu - 1,
								{
									text = "Skip Roll if Not Contested",
									tooltipText = "Just announce the winner instead of rolling on the item if it's reserved by only one player.|n|nOnly applies if the winner is online in the group.",
									checked = LootReserveHoU.Server.Settings.RollSkipNotContested,
									func = function(_, _, _, checked) LootReserveHoU.Server.Settings.RollSkipNotContested = checked; LootReserveHoU.Server:TryFinishRoll(); end,
								});
								table.insert(menu, #menu - 1,
								{
									text = "End Automatically",
									tooltipText = "Announce the winner and end the roll as soon as all reserving players rolled.",
									checked = LootReserveHoU.Server.Settings.RollFinishOnAllReservingRolled,
									func = function(_, _, _, checked) LootReserveHoU.Server.Settings.RollFinishOnAllReservingRolled = checked; LootReserveHoU.Server:TryFinishRoll(); end,
								});
							end
							if LootReserveHoU.Server.RequestedRoll.RaidRoll then
								if not separator then
									table.insert(menu, #menu - 1, LootReserveHoU:MakeMenuSeparator());
									separator = true;
								end
								table.insert(menu, #menu - 1,
								{
									text = "End Automatically",
									tooltipText = "Instantly announce the winner and end the raid-roll.",
									checked = LootReserveHoU.Server.Settings.RollFinishOnRaidRoll,
									func = function(_, _, _, checked) LootReserveHoU.Server.Settings.RollFinishOnRaidRoll = checked; LootReserveHoU.Server:TryFinishRoll(); end,
								});
							end

							LootReserveHoU:OpenMenu(menu, self:GetParent().Menu, self);
						else
							local winners = { };
							if LootReserveHoU.Server.CurrentSession.WonItems and LootReserveHoU.Server.CurrentSession.WonItems[self:GetParent().Item:GetID()] then
								for _, player in ipairs(LootReserveHoU.Server.CurrentSession.WonItems[self:GetParent().Item:GetID()].Players) do
									if LootReserveHoU:Contains(LootReserveHoU.Server.CurrentSession.ItemReserves[self:GetParent().Item:GetID()].Players, player) then
										table.insert(winners, player);
									end
								end
							end
							if #winners > 0 then
								StaticPopup_Show("LootReserveHoU_CONFIRM_ROLL_RESERVED_ITEM_AGAIN", self:GetParent().Link, format("%s:|n%s", #winners == 1 and "a reserver" or format("%d reservers", #winners), LootReserveHoU:FormatReservesTextColored(winners)), {Item = self:GetParent().Item});
							else
								LootReserveHoU.Server:RequestRoll(self:GetParent().Item);
							end
						end

						if GameTooltip:IsOwned(self) then
							self:UpdateTooltip();
						end
					</OnClick>
					<OnEnter>
						self:UpdateTooltip();
					</OnEnter>
					<OnLeave function="GameTooltip_Hide" />
				</Scripts>
				<NormalTexture file="Interface\Buttons\UI-GroupLoot-Dice-Up" />
				<HighlightTexture file="Interface\Buttons\UI-GroupLoot-Dice-Highlight" alphaMode="ADD" />
				<PushedTexture file="Interface\Buttons\UI-GroupLoot-Dice-Down" />
			</Button>
			<Button parentKey="ItemFrame" inherits="LootReserveHoUItemButtonTemplate" frameLevel="100">
				<KeyValues>
					<KeyValue key="tooltipRight" value="true" type="boolean" />
				</KeyValues>
				<Anchors>
					<Anchor point="TOPLEFT" x="6" y="-6" />
					<Anchor point="RIGHT" relativeKey="$parent.RequestRollButton" relativePoint="LEFT" x="-5" />
				</Anchors>
			</Button>
			<Frame parentKey="DurationFrame">
				<Size y="12" />
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.ItemFrame" relativePoint="BOTTOMLEFT" />
					<Anchor point="RIGHT" x="-6" />
				</Anchors>
				<Frames>
					<StatusBar parentKey="Duration" inherits="LootReserveHoUDurationStatusBar">
						<KeyValues>
							<KeyValue key="server" value="true" type="boolean" />
							<KeyValue key="roll" value="true" type="boolean" />
						</KeyValues>
						<Anchors>
							<Anchor point="LEFT" x="1" />
							<Anchor point="RIGHT" x="-1" />
							<Anchor point="BOTTOM" y="-1" />
						</Anchors>
					</StatusBar>
				</Frames>
			</Frame>
			<Button parentKey="DistributeButton" inherits="LootReserveHoUGlowingButtonTemplate" frameLevel="100" hidden="true" text="Distribute">
				<Size x="165" y="20" />
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.ItemFrame" relativePoint="BOTTOMLEFT" x="-1" y="-2" />
				</Anchors>
				<Layers>
					<Layer layer="OVERLAY">
						<Texture parentKey="Arrow" file="Interface\Minimap\MinimapArrow">
							<Size x="24" y="24" />
							<Anchors>
								<Anchor point="CENTER" relativeKey="$parent.Text" relativePoint="RIGHT" x="-8" />
							</Anchors>
						</Texture>
					</Layer>
				</Layers>
				<Scripts>
					<OnLoad inherit="prepend">
						function self:SetState(text, enable, glow)
							if self:GetText() ~= text then
								self:SetText(text);
							end
							if enable ~= self:IsEnabled() then
								self:SetEnabled(enable);
							end
							self:SetGlow(glow);
							-- if self.LibCustomGlow then
							-- 	if glow then
							-- 		self.LibCustomGlow.ButtonGlow_Start(self.Glow)
							-- 	else
							-- 		self.LibCustomGlow.ButtonGlow_Stop(self.Glow)
							-- 	end
							-- end
						end
						
						self.Locator = { };
						self.DMBLocate = function(self, unit)
							local _, playerClass = LootReserveHoU:UnitClass("player");
							local _, targetClass = LootReserveHoU:UnitClass(unit);
							local color1 = RAID_CLASS_COLORS[playerClass];
							local color2 = RAID_CLASS_COLORS[targetClass];
							
							if self.Locator.active then
								self.Locator.m1:Free(true);
								self.Locator.m2:Free(true);
								self.Locator.edge:Free(true);
								self.Locator.Timer:Cancel();
							end
							
							self.Locator.m1 = DBM.HudMap:RegisterRangeMarkerOnPartyMember(87654, "party", LootReserveHoU:Me(), 0.5, nil, color1.r, color1.g, color1.b, 1, nil, false);
							self.Locator.m2 = DBM.HudMap:RegisterRangeMarkerOnPartyMember(87654, "party", UnitName(unit), 0.75, nil, color2.r, color2.g, color2.b, 1, nil, false);
							self.Locator.edge = self.Locator.m2:EdgeTo(self.Locator.m1, nil, nil, 0, 1, 0, 1);
							
							-- Play appearing animation
							if not self.Locator.active then
								self.Locator.m1:Appear();
								self.Locator.m2:Appear();
							end
							
							self.Locator.m1:Update();
							self.Locator.m2:Update();
							self.Locator.edge:Update();
							
							self.Locator.Timer = C_Timer.NewTicker(5, function() self.Locator.m1:Free() self.Locator.m2:Free() self.active = nil end, 1);
							self.Locator.active = true;
						end
					</OnLoad>
					<OnUpdate>
						self.Arrow:Hide();
						local unit = self.Unit;
						
						if not unit or not UnitExists(unit) then
							return self:SetState("Can't find winner", false, false);
						end
						
						if not UnitIsConnected(unit) then
							return self:SetState("Winner is offline", false, false);
						end
						
						if self.Lootable then
							if C_Map.GetBestMapForUnit(unit) ~= C_Map.GetBestMapForUnit("player") then
								return self:SetState("Winner not found", false, false);
							end
							
							return self:SetState("Master loot", true, true);
							
						elseif self.Tradeable then
							if UnitIsUnit(unit, "player") then
								return self:SetState("Winner is me", false, false);
							end
							
							if UnitIsDeadOrGhost(unit) then
								return self:SetState("Winner is dead", false, false);
							end
							
							
							local playerContinent, playerPos = LootReserveHoU:GetContinent("player");
							local targetContinent, targetPos = LootReserveHoU:GetContinent(unit);
							
							if playerContinent ~= targetContinent then
								return self:SetState("Different instance", false, false);
							end
							
							local min, max, angle, distText = LootReserveHoU:GetRange(unit, playerPos, targetPos);
							
							if angle then
								self.Arrow:Show();
								self.Arrow:SetRotation(angle);
							end
							
							if not CheckInteractDistance(unit, 2) then
								if not (max or min) then
									return self:SetState(UnitIsVisible(unit) and "Approach" or "Travel", false, false);
								end
							
								if not LootReserveHoU:CanLocate() then
									return self:SetState(format("%s: %s", UnitIsVisible(unit) and "Approach" or "Travel", distText), false, false);
								end
								
								if not UnitInPhase(unit) or (not UnitIsVisible(unit) and (max or min) &lt;= 9) then
									return self:SetState(format("%s: %s", "Wrong Layer", distText), false, false);
								end
								
								if (max or min) &lt;= 9 then
									return self:SetState(format("%s: %s", "Above/Below", distText), false, false);
								end
								
								local prefix = "Travel"
								if UnitIsVisible(unit) then
									prefix = "Approach:"
								elseif min > 20000 then
									prefix = "LOL:"
								elseif min > 10000 then
									prefix = "Good luck:"
								elseif min > 500 then
									local roundDist = LootReserveHoU:Round(min+50, 100);
									if roundDist == self.lastRoundDist then
										prefix = self.lastRandPrefix;
									else
										prefix = self.lastRandPrefix;
										while prefix == self.lastRandPrefix do
											prefix = LootReserveHoU.Constants.LocomotionPhrases[math.random(1, #LootReserveHoU.Constants.LocomotionPhrases)];
										end
										self.lastRoundDist = roundDist;
										self.lastRandPrefix = prefix;
									end
								end
								
								local dbmLocator = LootReserveHoU:CanUseDBMLocator(unit);
								
								return self:SetState(format("%s %s", prefix, distText), dbmLocator, false);
							end
							
							if not TradeFrame:IsShown() then
								return self:SetState(format("%s: %s", "Open trade", distText), true, true);
							end
							if not UnitIsUnit("npc", unit) then
								return self:SetState(format("%s: %s", "Wrong trader", distText), false, false);
							end
							if not LootReserveHoU:IsItemBeingTraded(self:GetParent().Item) then
								for i = 1, 6 do
									if not GetTradePlayerItemInfo(i) then
										return self:SetState(format("%s: %s", "Insert item", distText), true, true);
									end
								end
								return self:SetState(format("%s: %s", "Finish trade", distText), false, false);
							end
							if LootReserveHoU.Server.TradeAcceptState[1] then
								return self:SetState(format("%s: %s", "Wait", distText), false, false);
							end
							
							return self:SetState(format("%s: %s", "Accept trade", distText), true, LootReserveHoUTradeFrameAutoButton:IsShown() and not LootReserveHoUTradeFrameAutoButton.ItemsToInsert);
						else
							return self:SetState("Can't find item", false, false);
						end
					</OnUpdate>
					<OnClick>
						local frame = self:GetParent();
						local item = frame.Item;
						local unit = self.Unit
						
						if not unit then return; end
						if self.Lootable then
							LootReserveHoU.Server:MasterLootItem(item, LootReserveHoU:Player(UnitName(unit)));
						elseif self.Tradeable then
							local bag, slot;
							for b = 0, NUM_BAG_SLOTS do
								for s = 1, GetContainerNumSlots(b) do
									local itemLink = select(7, GetContainerItemInfo(b, s));
									if itemLink and LootReserveHoU.ItemCache:Item(itemLink) == item and LootReserveHoU:IsTradeableItem(b, s) then
										bag, slot = b, s;
										break;
									end
								end
								if bag or slot then break; end
							end
							if bag and slot then
								if TradeFrame:IsShown() then
									if UnitIsUnit(unit, "npc") then
										if LootReserveHoU:IsItemBeingTraded(item) then
											AcceptTrade();
										else
											LootReserveHoU:PutItemInTrade(bag, slot);
										end
									end
								elseif CheckInteractDistance(unit, 2) then
									PickupContainerItem(bag, slot);
									DropItemOnUnit(unit);
									C_Timer.After(1, ClearCursor);
								elseif LootReserveHoU:CanUseDBMLocator(unit) then
									self:DMBLocate(unit);
								end
							end
						end
					</OnClick>
		  	</Scripts>
		  	<Frames>
					<Button parentKey="ClearOwedButton2" inherits="LootReserveHoUGlowingButtonTemplate" frameLevel="100" text="Clear" hidden="true">
						<Size x="35" y="20" />
						<Anchors>
							<Anchor point="LEFT" relativeKey="$parent" relativePoint="RIGHT" />
						</Anchors>
						<Scripts>
							<OnClick>
								self:GetParent():GetParent().Roll.Owed = nil;
								LootReserveHoU:TableRemove(LootReserveHoU.Server.OwedRolls, self:GetParent():GetParent().Roll);
								LootReserveHoU.Server:UpdateRollList();
							</OnClick>
				  	</Scripts>
					</Button>
					<Button parentKey="ClearOwedButton" inherits="UIMenuButtonStretchTemplate" frameLevel="100">
						<Size x="20" y="20" />
						<Anchors>
							<Anchor point="LEFT" relativeKey="$parent" relativePoint="RIGHT" />
						</Anchors>
						<Layers>
							<Layer>
								<Texture parentKey="Icon" file="Interface\Buttons\UI-GroupLoot-Pass-Up">
									<Size x="14" y="14" />
									<Anchors>
										<Anchor point="CENTER" />
									</Anchors>
								</Texture>
							</Layer>
						</Layers>
						<HighlightTexture file="Interface\Buttons\UI-Common-MouseHilight" alphaMode="ADD" />
						<Scripts>
							<OnLoad>
								self:SetPushedTextOffset(1, -1);
							</OnLoad>
							<OnMouseDown>
								self.Icon:SetPoint("CENTER", self, "CENTER", self:GetPushedTextOffset());
							</OnMouseDown>
							<OnMouseUp>
								self.Icon:SetPoint("CENTER", self, "CENTER");
							</OnMouseUp>
							<OnEnter>
								GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
								GameTooltip:SetText("Clear");
								GameTooltip:Show();
							</OnEnter>
							<OnClick inherit="prepend">
								self:GetParent():GetParent().Roll.Owed = nil;
								LootReserveHoU:TableRemove(LootReserveHoU.Server.OwedRolls, self:GetParent():GetParent().Roll);
								LootReserveHoU.Server:UpdateRollList();
							</OnClick>
							<OnLeave function="GameTooltip_Hide" />
						</Scripts>
					</Button>
		  	</Frames>
			</Button>
			<Frame parentKey="ReservesFrame">
				<Anchors>
					<Anchor point="LEFT" x="6" />
					<Anchor point="BOTTOMRIGHT" x="-6" y="6" />
				</Anchors>
				<Layers>
					<Layer level="OVERLAY">
						<FontString parentKey="HeaderRoll" inherits="GameFontNormalSmall" text="Roll" justifyH="CENTER" wordwrap="false">
							<Size x="32" y="12" />
							<Anchors>
								<Anchor point="TOPRIGHT" />
							</Anchors>
						</FontString>
						<FontString parentKey="HeaderPlayer" inherits="GameFontNormalSmall" text="Reserved by" justifyH="LEFT" wordwrap="false">
							<Size y="12" />
							<Anchors>
								<Anchor point="TOPLEFT" x="16" />
								<Anchor point="TOPRIGHT" relativeKey="$parent.HeaderRoll" relativePoint="TOPLEFT" />
							</Anchors>
						</FontString>
						<FontString parentKey="NoRollsPlaceholder" inherits="GameFontNormalSmall" text="- No Rolls -" justifyH="CENTER" wordwrap="false" hidden="true">
							<Size y="16" />
							<Anchors>
								<Anchor point="TOPLEFT" relativeKey="$parent.HeaderPlayer" relativePoint="BOTTOMLEFT" y="-2" />
								<Anchor point="TOPRIGHT" relativeKey="$parent.HeaderRoll" relativePoint="BOTTOMRIGHT" y="-2" />
							</Anchors>
							<Color r="0.5" g="0.5" b="0.5" />
						</FontString>
					</Layer>
					<Layer level="ARTWORK">
						<Texture parentKey="HeaderGlow" alpha="0.25" file="Interface\CHATFRAME\ChatFrameTab-NewMessage" alphaMode="ADD">
							<Size y="12" />
							<Anchors>
								<Anchor point="BOTTOMLEFT" relativeKey="$parent.HeaderPlayer" x="-16" y="-2" />
								<Anchor point="BOTTOMRIGHT" relativeKey="$parent.HeaderRoll" y="-2" />
							</Anchors>
							<Color r="1" g="0.82" b="0" />
						</Texture>
						<Texture alpha=".5" file="Interface\CHATFRAME\ChatFrameTab-NewMessage" alphaMode="ADD">
							<Size y="3" />
							<Anchors>
								<Anchor point="BOTTOMLEFT" relativeKey="$parent.HeaderGlow" x="16" />
								<Anchor point="BOTTOMRIGHT" relativeKey="$parent.HeaderGlow" x="-16" />
							</Anchors>
							<Color r="1" g="1" b="1" />
						</Texture>
					</Layer>
				</Layers>
				<Frames>
					<Button parentKey="ReportRolls">
						<Size x="12" y="12" />
						<Anchors>
							<Anchor point="RIGHT" relativeKey="$parent.HeaderPlayer" relativePoint="LEFT" x="-2" />
						</Anchors>
						<NormalTexture file="Interface\Buttons\UI-GuildButton-MOTD-Up" alpha="0.25" />
						<PushedTexture file="Interface\Buttons\UI-GuildButton-MOTD-Up" alpha="0" />
						<HighlightTexture file="Interface\Buttons\UI-GuildButton-MOTD-Up" alphaMode="ADD" alpha="0.75" />
						<Scripts>
							<OnClick>
								local function MakeChatColoredText(text, chatType)
									local info = ChatTypeInfo[chatType or "RAID_WARNING"];
									return format("|cff%02x%02x%02x%s|r", info.r * 255, info.g * 255, info.b * 255, text);
								end
								local function MakeReportButton(text, chatType, condition)
									return
									{
										text = condition and MakeChatColoredText(text, chatType) or text,
										arg1 = chatType,
										disabled = not condition,
										func = function(info)
											local frame = self:GetParent():GetParent();
											if not frame.Roll then return; end
											local recipient = UnitIsPlayer("target") and UnitIsConnected("target") and UnitName("target");
											if info.arg1 == "WHISPER" and not recipient then
												LootReserveHoU:PrintError("Target is not a valid player to whisper.")
											  return;
											end

											local totalRolls = 0;
											for player, rolls in pairs(frame.Roll.Players) do
												for _, roll in ipairs(rolls) do
													if roll > LootReserveHoU.Constants.RollType.NotRolled then
														totalRolls = totalRolls + 1;
													end
												end
											end
											if self.Lines and self.Lines >= totalRolls then
												self.Lines = nil;
											end

											LootReserveHoU:SendChatMessage(format("%s for %s%s%s:",
												(not self.Lines or self.Lines == 0) and "Rolls" or format("Top %d out of %d %s", self.Lines, totalRolls, totalRolls == 1 and "roll" or "rolls"),
												frame.Link,
												frame.Roll.Phases and format(" for %s", frame.Roll.Phases[1] or "") or "",
												frame.Historical and format(" on %s", (frame.ItemFrame.Misc:GetText() or ""):gsub("%s%s", " at ")) or ""
											), info.arg1, recipient);
											local i = 1;
											for player, roll, rollNumber in LootReserveHoU.Server:GetOrderedPlayerRolls(frame.Roll.Players) do
												if roll > LootReserveHoU.Constants.RollType.NotRolled and (not self.Lines or self.Lines == 0 or self.Lines >= i) then
													LootReserveHoU:SendChatMessage(format("  %d by %s", roll, player), info.arg1, recipient);
													i = i + 1;
												end
											end
											if i == 1 then
												if frame.Roll.Winners then
													LootReserveHoU:SendChatMessage(format("  %s by %s", frame.Roll.Disenchant and "Disenchanted" or "Reserved", frame.Roll.Winners[1]), info.arg1, recipient);
												else
													LootReserveHoU:SendChatMessage("  No Rolls", info.arg1, recipient);
												end
											end
										end,
									};
								end

								local menu =
								{
									{ text = "Report", isTitle = true },
									LootReserveHoU:MakeMenuSeparator(),
									{ text = "To Chat", isTitle = true },
									MakeReportButton("/rw", "RAID_WARNING", IsInRaid() and (UnitIsGroupLeader("player") or UnitIsGroupAssistant("player"))),
									MakeReportButton("/raid", "RAID", IsInRaid()),
									MakeReportButton("/party", "PARTY", IsInGroup()),
									MakeReportButton("/guild", "GUILD", IsInGuild()),
									MakeReportButton("/officer", "OFFICER", IsInGuild() and C_GuildInfo.GuildControlGetRankFlags(({GetGuildInfo("player")})[3]+1)[4]),
									MakeReportButton("/whisper [target]", "WHISPER", true),
									LootReserveHoU:MakeMenuSeparator(),
									{ text = "Cancel" },
								};

								local roll = self:GetParent():GetParent().Roll;
								if not roll then return; end

								local totalRolls = 0;
								for player, rolls in pairs(roll.Players) do
									for _, roll in ipairs(rolls) do
										if roll > LootReserveHoU.Constants.RollType.NotRolled then
											totalRolls = totalRolls + 1;
										end
									end
								end
								local i = 0;
								for _, lines in ipairs({ 1, 2, 3, 4, 5, 10, 0 }) do
									if totalRolls > lines or lines == 0 then
										i = i + 1;
										table.insert(menu, 1 + i,
										{
											text = format(lines == 0 and "All Rolls" or "Top %d %s", lines, lines == 1 and "Roll" or "Rolls"),
											arg1 = lines,
											checked = not self.Lines or self.Lines == 0 or lines > 0 and (self.Lines or 0) >= lines,
											func = function(info) self.Lines = info.arg1; LootReserveHoU:ReopenMenu(self); end
										});
									end
								end

								LootReserveHoU:OpenMenu(menu, self:GetParent().Menu, self);
							</OnClick>
						</Scripts>
					</Button>
					<Button parentKey="ReportReserves">
						<Size x="12" y="12" />
						<Anchors>
							<Anchor point="TOPLEFT" relativeKey="$parent.ReportRolls" x="1" />
							<Anchor point="BOTTOMRIGHT" relativeKey="$parent.ReportRolls" x="-1" />
						</Anchors>
						<NormalTexture file="Interface\Buttons\UI-GuildButton-MOTD-Up" alpha="0.25" />
						<PushedTexture file="Interface\Buttons\UI-GuildButton-MOTD-Up" alpha="0" />
						<HighlightTexture file="Interface\Buttons\UI-GuildButton-MOTD-Up" alphaMode="ADD" alpha="0.75" />
						<Scripts>
							<OnClick>
								local function MakeChatColoredText(text, chatType)
									local info = ChatTypeInfo[chatType or "RAID_WARNING"];
									return format("|cff%02x%02x%02x%s|r", info.r * 255, info.g * 255, info.b * 255, text);
								end
								local function MakeReportButton(text, chatType, condition)
									return
									{
										text = condition and MakeChatColoredText(text, chatType) or text,
										arg1 = chatType,
										disabled = not condition,
										func = function(info)
											local frame = self:GetParent():GetParent();
											local recipient = UnitIsPlayer("target") and UnitIsConnected("target") and UnitName("target");
											if info.arg1 == "WHISPER" and not recipient then
												LootReserveHoU:PrintError("Target is not a valid player to whisper.")
											  return;
											end

											local reservesText = LootReserveHoU:GetReservesData(LootReserveHoU.Server.CurrentSession.ItemReserves[frame.Item:GetID()].Players);
											LootReserveHoU:SendChatMessage(format("Reserves for %s: %s", frame.Link, reservesText), info.arg1, recipient);
										end,
									};
								end

								local menu =
								{
									{ text = "Report", isTitle = true },
									LootReserveHoU:MakeMenuSeparator(),
									{ text = "To Chat", isTitle = true },
									MakeReportButton("/rw", "RAID_WARNING", IsInRaid() and (UnitIsGroupLeader("player") or UnitIsGroupAssistant("player"))),
									MakeReportButton("/raid", "RAID", IsInRaid()),
									MakeReportButton("/party", "PARTY", IsInGroup()),
									MakeReportButton("/guild", "GUILD", IsInGuild()),
									MakeReportButton("/officer", "OFFICER", IsInGuild() and C_GuildInfo.GuildControlGetRankFlags(({GetGuildInfo("player")})[3]+1)[4]),
									MakeReportButton("/whisper [target]", "WHISPER", true),
									LootReserveHoU:MakeMenuSeparator(),
									{ text = "Cancel" },
								};

								LootReserveHoU:OpenMenu(menu, self:GetParent().Menu, self);
							</OnClick>
						</Scripts>
					</Button>
					<Frame parentKey="Menu" inherits="UIDropDownMenuTemplate" hidden="true" />
				</Frames>
			</Frame>
		</Frames>
	</Frame>
	<Button name="LootReserveHoUTradeFrameAutoButton" inherits="UIPanelButtonTemplate" parent="TradeFrame" hidden="true">
		<Size x="168" />
		<Anchors>
			<Anchor point="TOP" relativeTo="TradeFrameTradeButton" relativePoint="TOP" />
			<Anchor point="BOTTOM" relativeTo="TradeFrameTradeButton" relativePoint="BOTTOM" />
			<Anchor point="RIGHT" relativeTo="TradeFrameTradeButton" relativePoint="LEFT" x="-3" />
		</Anchors>
		<Scripts>
			<OnClick>
				if self.ItemsToInsert then
					local i = 1;
					for _, item in ipairs(self.ItemsToInsert) do
						while GetTradePlayerItemInfo(i) do
							i = i + 1;
						end
						if i > 6 then
							return;
						end
						local bag, slot = LootReserveHoU:GetBagSlot(item);
						if bag and slot then
							PickupContainerItem(bag, slot);
							ClickTradeButton(i);
							i = i + 1;
						end
					end
				else
					AcceptTrade();
				end
			</OnClick>
		</Scripts>
	</Button>
	<Frame name="LootReserveHoURollPlaceholderTemplate" virtual="true" enableMouse="true" inherits="LootReserveHoUBackdropTemplate">
		<KeyValues>
			<KeyValue key="backdropInfo" value="LootReserveHoU_BACKDROP_BLACK_4" type="global" />
		</KeyValues>
		<Backdrop bgFile="Interface\DialogFrame\UI-DialogBox-Background" edgeFile="Interface\Tooltips\UI-Tooltip-Border">
			<BackgroundInsets left="5" right="5" top="5" bottom="5" />
			<EdgeSize val="16" />
			<BorderColor r="1" g="1" b="1" a="1" />
		</Backdrop>
		<Frames>
			<Button parentKey="RequestRollButton" hidden="true">
				<Size x="32" y="32" />
				<Anchors>
					<Anchor point="TOPRIGHT" x="-6" y="-6" />
				</Anchors>
				<Scripts>
					<OnClick>
						local function StartRoll(info)
							local frame = self:GetParent();
							local item = frame.Item;
							frame:SetItem(nil);
							local token;
							if not LootReserveHoU.Server.ReservableIDs[item:GetID()] and LootReserveHoU.Server.ReservableRewardIDs[item:GetID()] then
								token = LootReserveHoU.ItemCache:Item(LootReserveHoU.Data:GetToken(item:GetID())) or LootReserveHoU.ItemCache:Item(LootReserveHoU.Data:GetToken(item:GetID()));
							end
							if info and info.arg1 and LootReserveHoU.Server.CurrentSession and LootReserveHoU.Server.CurrentSession.ItemReserves[token and token:GetID() or item:GetID()] then
								LootReserveHoU.Server:RequestRoll(item);
							else
								local phases = LootReserveHoU.Server.Settings.RollUsePhases and #LootReserveHoU.Server.Settings.RollPhases > 0 and LootReserveHoU.Server.Settings.RollPhases or nil;
								if info.arg2 then
									phases = LootReserveHoU:Deepcopy(LootReserveHoU.Server.Settings.RollPhases)
									for i = 2, info.arg2 do
										table.remove(phases, 1)
									end
								end
								LootReserveHoU.Server:RequestCustomRoll(item,
									LootReserveHoU.Server.Settings.RollLimitDuration and LootReserveHoU.Server.Settings.RollDuration or nil,
									phases);
							end
						end
						local function RaidRoll()
							local frame = self:GetParent();
							local item = frame.Item;
							frame:SetItem(nil);
							LootReserveHoU.Server:RaidRoll(item);
						end

						-- Roll Phases
						local phaseMenu = { };
						for _, contains in ipairs({ true, false }) do
							local first = true;
							local i = 0;
							for _, phase in ipairs(contains and LootReserveHoU.Server.Settings.RollPhases or LootReserveHoU.Server.Settings.Phases) do
								if LootReserveHoU:Contains(LootReserveHoU.Server.Settings.RollPhases, phase) == contains then
									if #phaseMenu > 0 and first then
										table.insert(phaseMenu, LootReserveHoU:MakeMenuSeparator());
									end
									first = false;
									i = i + 1;
									table.insert(phaseMenu,
									{
										text = contains and format("|cFF00FF00%d. %s|r", i, phase) or phase,
										arg1 = phase,
										arg2 = contains,
										func = function(info, phase, contains)
											if contains then
												for index, i in ipairs(LootReserveHoU.Server.Settings.RollPhases) do
													if i == phase then
														table.remove(LootReserveHoU.Server.Settings.RollPhases, index);
														break;
													end
												end
											else
												table.insert(LootReserveHoU.Server.Settings.RollPhases, phase);
											end
											LootReserveHoU:ReopenMenu(self, "#phases");
										end,
										checked = contains,
									});
								end
							end
						end
						if #phaseMenu > 0 then
							table.insert(phaseMenu, LootReserveHoU:MakeMenuSeparator());
						end
						table.insert(phaseMenu, { text = "Manage", isTitle = true });
						table.insert(phaseMenu, { text = "Add...", func = function()
							CloseMenus();
							StaticPopup_Show("LootReserveHoU_NEW_PHASE_NAME");
						end });
						local removePhasesMenu = { };
						for _, phase in ipairs(LootReserveHoU.Server.Settings.Phases) do
							table.insert(removePhasesMenu, { text = phase, arg1 = phase, func = function(info)
								LootReserveHoU:TableRemove(LootReserveHoU.Server.Settings.Phases, info.arg1);
								LootReserveHoU:TableRemove(LootReserveHoU.Server.Settings.RollPhases, info.arg1);
								LootReserveHoU:ReopenMenu(self, "#phases");
							end });
						end
						table.insert(phaseMenu, { text = "Remove...", menuList = removePhasesMenu });
						table.insert(phaseMenu, { text = "Reset", func = function()
							CloseMenus();
							StaticPopup_Show("LootReserveHoU_CONFIRM_RESET_PHASES");
						end });

						-- Roll Duration
						local function FormatTime(time)
							return format("%d:%02d", math.floor(time / 60), time % 60);
						end
						local durationMenu = { };
						table.insert(durationMenu, { text = "Duration", isTitle = true });
						for _, time in ipairs({ 10, 15, 20, 30, 45, 60, 90, 120, 180, 240, 300, 600 }) do
							table.insert(durationMenu,
							{
								text = FormatTime(time),
								arg1 = time,
								func = function(info, time) LootReserveHoU.Server.Settings.RollDuration = time; LootReserveHoU:ReopenMenu(self, "#duration"); end,
								checked = LootReserveHoU.Server.Settings.RollDuration == time,
							});
						end
						table.insert(durationMenu, LootReserveHoU:MakeMenuSeparator());
							table.insert(durationMenu,
							{
								text = "Accept Late Rolls",
								tooltipText = "Accept rolls even if the duration has ended.",
								checked = LootReserveHoU.Server.Settings.AcceptRollsAfterTimerEnded,
								func = function(_, _, _, checked) LootReserveHoU.Server.Settings.AcceptRollsAfterTimerEnded = checked; LootReserveHoU:ReopenMenu(self, "#duration"); end,
							});
						table.insert(durationMenu, LootReserveHoU:MakeMenuSeparator());
						table.insert(durationMenu, { text = "Countdown", isTitle = true });
						for _, time in ipairs({ 0, 3, 5, 10 }) do
							time = time ~= 0 and time or nil;
							table.insert(durationMenu,
							{
								text = time and format("%d secs", time) or "Disabled",
								arg1 = time,
								func = function(info, time) LootReserveHoU.Server.Settings.RollCountdown = time; LootReserveHoU:ReopenMenu(self, "#duration"); end,
								checked = LootReserveHoU.Server.Settings.RollCountdown == time,
							});
						end

						-- Disenchanter
						local disenchanterMenu = { };
						for _, contains in ipairs({ true, false }) do
							local first = true;
							local i = 0;
							for _, name in ipairs(contains and LootReserveHoU.Server.Settings.RollDisenchanters or LootReserveHoU.Server.Settings.Disenchanters) do
								if LootReserveHoU:Contains(LootReserveHoU.Server.Settings.RollDisenchanters, name) == contains then
									if #disenchanterMenu > 0 and first then
										table.insert(disenchanterMenu, LootReserveHoU:MakeMenuSeparator());
									end
									first = false;
									i = i + 1;
									table.insert(disenchanterMenu,
									{
										text = contains and format("|cFF00FF00%d. %s|r", i, LootReserveHoU:ColoredPlayer(name)) or LootReserveHoU:ColoredPlayer(name),
										arg1 = name,
										arg2 = contains,
										func = function(info, name, contains)
											if contains then
												for index, i in ipairs(LootReserveHoU.Server.Settings.RollDisenchanters) do
													if i == name then
														table.remove(LootReserveHoU.Server.Settings.RollDisenchanters, index);
														break;
													end
												end
											else
												table.insert(LootReserveHoU.Server.Settings.RollDisenchanters, name);
											end
											LootReserveHoU:ReopenMenu(self, "#disenchanters");
										end,
										checked = contains,
									});
								end
							end
						end
						if #disenchanterMenu > 0 then
							table.insert(disenchanterMenu, LootReserveHoU:MakeMenuSeparator());
						end
						table.insert(disenchanterMenu, { text = "Manage", isTitle = true });
						local disenchanters = { };
						LootReserveHoU:ForEachRaider(function(name)
							disenchanters[name] = true;
						end)
						for name in pairs(LootReserveHoU.Server.CurrentSession and LootReserveHoU.Server.CurrentSession.Members or LootReserveHoU.Server.NewSessionSettings and LootReserveHoU.Server.NewSessionSettings.ImportedMembers or {}) do
							disenchanters[name] = true;
						end
						local disenchantersList = { };
						for name in pairs(disenchanters) do
							if not LootReserveHoU:Contains(LootReserveHoU.Server.Settings.Disenchanters, name) then
								table.insert(disenchantersList, name);
							end
						end
						table.sort(disenchantersList, function(a, b) return b >= a end);
						local addDisenchantersMenu = { };
						for _, name in ipairs(disenchantersList) do
							table.insert(addDisenchantersMenu, { text = LootReserveHoU:ColoredPlayer(name), func = function(info)
								table.insert(LootReserveHoU.Server.Settings.Disenchanters, name);
								LootReserveHoU:ReopenMenu(self, "#disenchanters");
							end });
						end
						table.insert(disenchanterMenu, { text = "Add...", menuList = addDisenchantersMenu });
						local removeDisenchantersMenu = { };
						for _, name in ipairs(LootReserveHoU.Server.Settings.Disenchanters) do
							table.insert(removeDisenchantersMenu, { text = LootReserveHoU:ColoredPlayer(name), arg1 = name, func = function(info)
								LootReserveHoU:TableRemove(LootReserveHoU.Server.Settings.Disenchanters, info.arg1);
								LootReserveHoU:TableRemove(LootReserveHoU.Server.Settings.RollDisenchanters, info.arg1);
								LootReserveHoU:ReopenMenu(self, "#disenchanters");
							end });
						end
						table.insert(disenchanterMenu, { text = "Remove...", menuList = removeDisenchantersMenu });
						table.insert(disenchanterMenu, { text = "Clear", func = function()
							CloseMenus();
							StaticPopup_Show("LootReserveHoU_CONFIRM_RESET_DISENCHANTERS");
						end });
						
						local item, link = self:GetParent().Item, self:GetParent().Link;
						local token;
						if not LootReserveHoU.Server.ReservableIDs[item:GetID()] and LootReserveHoU.Server.ReservableRewardIDs[item:GetID()] then
							token = LootReserveHoU.ItemCache:Item(LootReserveHoU.Data:GetToken(item:GetID())) or LootReserveHoU.ItemCache:Item(LootReserveHoU.Data:GetToken(item:GetID()));
						end

						local disenchanter = LootReserveHoU.Server:GetDisenchanter();
						local menu =
						{
							{ text = "Start Roll", isTitle = true },
							{ text = "Among Reserving Players", arg1 = true, disabled = not LootReserveHoU.Server.CurrentSession or not LootReserveHoU.Server.CurrentSession.ItemReserves[token and token:GetID() or item:GetID()], func = function(...)
								local winners = { };
								if LootReserveHoU.Server.CurrentSession.WonItems and LootReserveHoU.Server.CurrentSession.WonItems[token and token:GetID() or item:GetID()] then
									for _, player in ipairs(LootReserveHoU.Server.CurrentSession.WonItems[token and token:GetID() or item:GetID()].Players) do
										if LootReserveHoU:Contains(LootReserveHoU.Server.CurrentSession.ItemReserves[token and token:GetID() or item:GetID()].Players, player) then
											table.insert(winners, player);
										end
									end
								end
								if #winners > 0 then
									StaticPopup_Show("LootReserveHoU_CONFIRM_ROLL_RESERVED_ITEM_AGAIN", link, format("%s:|n%s", #winners == 1 and "a reserver" or format("%d reservers", #winners), LootReserveHoU:FormatReservesTextColored(winners)), {Frame = self:GetParent(), Item = item});
								else
									StartRoll(...);
								end
							end, },
							{ text = "Auto Raid-Roll", func = RaidRoll },
							LootReserveHoU:MakeMenuSeparator(),
							-- Master Loot options go here
							LootReserveHoU:MakeMenuSeparator(),
							{ text = "Settings for \"Reserving Players\"", isTitle = true },
							{
								text = "Skip Roll if Not Contested",
								tooltipText = "Just announce the winner instead of rolling on the item if it's reserved by only one player.|n|nOnly applies if the winner is online in the group.",
								checked = LootReserveHoU.Server.Settings.RollSkipNotContested,
								func = function(_, _, _, checked) LootReserveHoU.Server.Settings.RollSkipNotContested = checked; end,
							},
							{
								text = "End Automatically",
								tooltipText = "Announce the winner and end the roll as soon as all reserving players rolled.",
								checked = LootReserveHoU.Server.Settings.RollFinishOnAllReservingRolled,
								func = function(_, _, _, checked) LootReserveHoU.Server.Settings.RollFinishOnAllReservingRolled = checked; end,
							},
							LootReserveHoU:MakeMenuSeparator(),
							{ text = "Settings for \"All Players\"", isTitle = true },
							{
								text = format(LootReserveHoU.Server.Settings.RollUsePhases and "Roll For: |cFF00FF00%s|r" or "Roll For...", strjoin(", ", unpack(LootReserveHoU.Server.Settings.RollPhases))),
								arg1 = "#phases",
								checked = LootReserveHoU.Server.Settings.RollUsePhases,
								func = function(_, _, _, checked) LootReserveHoU.Server.Settings.RollUsePhases = checked; LootReserveHoU:ReopenMenu(self); end,
								hasArrow = LootReserveHoU.Server.Settings.RollUsePhases,
								menuList = phaseMenu,
							},
							{
								text = format(disenchanter and "Disenchanter: %s" or "Disenchant", disenchanter and LootReserveHoU:ColoredPlayer(disenchanter)),
								arg1 = "#disenchanters",
								checked = LootReserveHoU.Server.Settings.RollDisenchant,
								func = function(_, _, _, checked) LootReserveHoU.Server.Settings.RollDisenchant = checked; LootReserveHoU:ReopenMenu(self); end,
								hasArrow = LootReserveHoU.Server.Settings.RollDisenchant,
								menuList = disenchanterMenu,
							},
							{
								text = format(LootReserveHoU.Server.Settings.RollLimitDuration and (LootReserveHoU.Server.Settings.RollCountdown and "Limit Duration: |cFF00FF00%s|r|cFF808080 (%d secs C/D)|r" or "Limit Duration: |cFF00FF00%s|r") or "Limit Duration", FormatTime(LootReserveHoU.Server.Settings.RollDuration), LootReserveHoU.Server.Settings.RollCountdown),
								arg1 = "#duration",
								checked = LootReserveHoU.Server.Settings.RollLimitDuration,
								func = function(_, _, _, checked) LootReserveHoU.Server.Settings.RollLimitDuration = checked; LootReserveHoU:ReopenMenu(self); end,
								hasArrow = LootReserveHoU.Server.Settings.RollLimitDuration,
								menuList = durationMenu,
							},
							{
								text = "Advance Automatically",
								tooltipText = "Advance to the next stage when the timer expires if nobody rolled.",
								disabled = not LootReserveHoU.Server.Settings.RollUsePhases or #LootReserveHoU.Server.Settings.RollPhases &lt;= 1 or not LootReserveHoU.Server.Settings.RollLimitDuration,
								checked = LootReserveHoU.Server.Settings.RollAdvanceOnExpire,
								func = function(_, _, _, checked) LootReserveHoU.Server.Settings.RollAdvanceOnExpire = checked; end,
							},
							{
								text = "End Automatically",
								tooltipText = "Announce the winner and end the roll when the timer expires.",
								disabled = not LootReserveHoU.Server.Settings.RollLimitDuration,
								checked = LootReserveHoU.Server.Settings.RollFinishOnExpire,
								func = function(_, _, _, checked) LootReserveHoU.Server.Settings.RollFinishOnExpire = checked; end,
							},
							LootReserveHoU:MakeMenuSeparator(),
							{ text = "Settings for \"Raid-Roll\"", isTitle = true },
							{
								text = "End Automatically",
								tooltipText = "Instantly announce the winner and end the raid-roll.",
								checked = LootReserveHoU.Server.Settings.RollFinishOnRaidRoll,
								func = function(_, _, _, checked) LootReserveHoU.Server.Settings.RollFinishOnRaidRoll = checked; end,
							},
							LootReserveHoU:MakeMenuSeparator(),
							{ text = "Cancel" },
						};

						local warning = (function()
							if not IsMasterLooter() or GetLootMethod() ~= "master" then
								return "Not master looter";
							end
							if not LootReserveHoU:IsLootingItem(item) then
								return "Item not in loot";
							end
							local name, link, quality = item:GetInfo();
							if not name or not quality or GetLootThreshold() > quality then
								return "Quality below threshold";
							end
						end)();
						if warning then
							table.insert(menu, 5,
							{
								text = format("Warning: %s", warning),
								disabled = true,
							});
						end
						table.insert(menu, 5,
						{
							text = "Master Loot to Winner",
							tooltipText = "Automatically masterloot the item away to the roll winner once they're announced.",
							checked = LootReserveHoU.Server.Settings.RollMasterLoot,
							func = function(_, _, _, checked) LootReserveHoU.Server.Settings.RollMasterLoot = checked; end,
						});
						
						table.insert(menu, 3,
						{ text = format(disenchanter and "To Disenchanter: %s" or "To Disenchanter", disenchanter and LootReserveHoU:ColoredPlayer(disenchanter)),
							disabled = not disenchanter,
							func = function(...)
								if not LootReserveHoU.Server.CurrentSession or not LootReserveHoU.Server.CurrentSession.ItemReserves[token and token:GetID() or item:GetID()] then
									self:GetParent():SetItem(nil);
									LootReserveHoU.Server:RecordDisenchant(item, disenchanter, true);
								else
									StaticPopup_Show("LootReserveHoU_CONFIRM_DISENCHANT_RESERVED_ITEM", link, LootReserveHoU:FormatReservesTextColored(LootReserveHoU.Server.CurrentSession.ItemReserves[token and token:GetID() or item:GetID()].Players), {Item = item, Disenchanter = disenchanter, Frame = self:GetParent()});
								end
							end,
						});
						
						if LootReserveHoU.Server.Settings.RollUsePhases and #LootReserveHoU.Server.Settings.RollPhases > 0 then
							for i = #LootReserveHoU.Server.Settings.RollPhases, 1, -1 do
								table.insert(menu, 3,
								{ text = format("Among All Players (|cff00ff00%s|r)", LootReserveHoU.Server.Settings.RollPhases[i]), arg2 = i, func = function(...)
									if not LootReserveHoU.Server.CurrentSession or not LootReserveHoU.Server.CurrentSession.ItemReserves[token and token:GetID() or item:GetID()] then
										StartRoll(...)
									else
										StaticPopup_Show("LootReserveHoU_CONFIRM_CUSTOM_ROLL_RESERVED_ITEM", link, LootReserveHoU:FormatReservesTextColored(LootReserveHoU.Server.CurrentSession.ItemReserves[token and token:GetID() or item:GetID()].Players), {Item = item, Frame = self:GetParent(), Phase = i});
									end
								end });
							end
						else
							table.insert(menu, 3,
							{ text = "Among All Players", func = function(...)
								if not LootReserveHoU.Server.CurrentSession or not LootReserveHoU.Server.CurrentSession.ItemReserves[token and token:GetID() or item:GetID()] then
									StartRoll(...)
								else
									StaticPopup_Show("LootReserveHoU_CONFIRM_CUSTOM_ROLL_RESERVED_ITEM", link, LootReserveHoU:FormatReservesTextColored(LootReserveHoU.Server.CurrentSession.ItemReserves[token and token:GetID() or item:GetID()].Players), {Item = item, Frame = self:GetParent()});
								end
							end });
						end

						LootReserveHoU:OpenMenu(menu, self:GetParent().Menu, self);
					</OnClick>
					<OnEnter>
						GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
						GameTooltip:SetText("Start Roll");
						GameTooltip:Show();
					</OnEnter>
					<OnLeave function="GameTooltip_Hide" />
				</Scripts>
				<NormalTexture file="Interface\Buttons\UI-GroupLoot-Dice-Up" />
				<HighlightTexture file="Interface\Buttons\UI-GroupLoot-Dice-Highlight" alphaMode="ADD" />
				<PushedTexture file="Interface\Buttons\UI-GroupLoot-Dice-Down" />
			</Button>
			<Frame parentKey="Menu" inherits="UIDropDownMenuTemplate" hidden="true" />
			<Button parentKey="ItemFrame">
				<Size y="32" />
				<Anchors>
					<Anchor point="TOPLEFT" x="6" y="-6" />
					<Anchor point="TOPRIGHT" relativeKey="$parent.RequestRollButton" relativePoint="TOPLEFT" x="-5" />
				</Anchors>
				<Frames>
					<Button parentKey="Icon" enableMouse="true">
						<Size x="32" y="32" />
						<Anchors>
							<Anchor point="TOPLEFT" />
						</Anchors>
						<Layers>
							<Layer level="BACKGROUND">
								<Texture file="Interface\Buttons\UI-EmptySlot-Disabled">
									<Size x="40" y="40" />
									<Anchors>
										<Anchor point="TOPLEFT" x="-4" y="4" />
									</Anchors>
									<TexCoords left="0.140625" right="0.84375" top="0.140625" bottom="0.84375" />
								</Texture>
							</Layer>
							<Layer level="BORDER">
								<Texture parentKey="Texture" setAllPoints="true" nonBlocking="true" />
							</Layer>
							<Layer level="OVERLAY">
								<Texture parentKey="CancelIcon" file="Interface\Buttons\UI-GroupLoot-Pass-Up" hidden="true">
									<Size x="16" y="16" />
									<Anchors>
										<Anchor point="CENTER" />
									</Anchors>
								</Texture>
								<Texture parentKey="Arrow" file="Interface\Buttons\Arrow-Down-Up" hidden="true">
									<Size x="16" y="16" />
									<Anchors>
										<Anchor point="BOTTOM" y="-10" />
									</Anchors>
								</Texture>
							</Layer>
						</Layers>
						<PushedTexture file="Interface\Buttons\UI-Quickslot-Depress"/>
						<HighlightTexture file="Interface\Buttons\ButtonHilight-Square" alphaMode="ADD" />
						<Scripts>
							<OnLoad>
								self:RegisterForDrag("LeftButton");
								self.DropHandler = function(self)
									local frame = self:GetParent():GetParent();
									local infoType, itemID, link = GetCursorInfo();
									ClearCursor();
									if infoType == "item" and link then
										frame:SetItem(link);
										CloseMenus();
									elseif frame.Item then
										frame:SetItem(nil);
										CloseMenus();
									else
										local function SelectItem(info)
											if IsShiftKeyDown() then
											  LootReserveHoU:TableRemove(LootReserveHoU.Server.RecentLoot, info.arg1);
											  return self:DropHandler();
											elseif IsControlKeyDown() then
												-- clear suffix if it has one
												LootReserveHoU.ItemCache:Item(info.arg1:GetID()):OnCache(function(item) StaticPopup_Show("LootReserveHoU_CONFIRM_ADD_TO_RECENT_LOOT_BLACKLIST", item:GetLink(), nil, {item = item}) end);
											  return self:DropHandler();
											else
												frame:SetItem(info.arg1);
												CloseMenus();
											end
										end
										local missing = { };
										local function MakeItem(count, item, texture)
											if count == 1 then
												count = nil;
											end
											local link = item:GetLink();
											if not link or not texture then
												texture = item:GetTexture();
												if not link then
													table.insert(missing, item);
												end
											end
					            local token;
					            if not LootReserveHoU.Server.ReservableIDs[item:GetID()] and LootReserveHoU.Server.ReservableRewardIDs[item:GetID()] then
					              token = LootReserveHoU.ItemCache:Item(LootReserveHoU.Data:GetToken(item:GetID()));
					            end
					            local notBoP = item:IsBindOnPickup() and "" or " |TInterface\\MINIMAP\\TRACKING\\Auctioneer:0|t";
											return
											{
												text = format("|T%d:0|t%s %s%s%s", texture, notBoP, LootReserveHoU.Server.CurrentSession and LootReserveHoU.Server.CurrentSession.ItemReserves[token and token:GetID() or item:GetID()] and (select(3, LootReserveHoU:GetReservesData(LootReserveHoU.Server.CurrentSession.ItemReserves[token and token:GetID() or item:GetID()].Players)) .. "x|TInterface/Buttons/UI-GroupLoot-Dice-Up:0|t ") or "", (link or "|cFFFF0000Loading...|r"):gsub("[%[%]]", ""), count and format("|cFF808080 x%d|r", count) or ""),
												arg1 = item,
												func = SelectItem,
												tooltipOnButton = item:GetString(), -- Not how this is supposed to be used
											};
										end
										local bagMenus = { };
										for bag = 0, 4 do
											local slots = GetContainerNumSlots(bag);
											if slots > 0 then
												local bagMenu = { };
												table.insert(bagMenus, bagMenu);
												for slot = 1, slots do
													local texture, count, _, _, _, _, link = GetContainerItemInfo(bag, slot);
													if link and (not C_Item.IsBound(ItemLocation:CreateFromBagAndSlot(bag, slot)) or LootReserveHoU:IsItemSoulboundTradeable(bag, slot)) then
														table.insert(bagMenu, MakeItem(count, LootReserveHoU.ItemCache:Item(link), texture));
													end
												end
											end
										end
										local menu =
										{
											{ text = "Recent Loot", isTitle = true },
											LootReserveHoU:MakeMenuSeparator(),
											{ text = "Bags", isTitle = true },
											LootReserveHoU:MakeMenuSeparator(),
											{ text = "Settings", arg1 = "#recentSettings", menuList = {
												{ text = format("Max Items: |cFF00FF00%d|r", LootReserveHoU.Server.Settings.MaxRecentLoot), arg1 = "#max", menuList = {
													{ text =  "0", checked = LootReserveHoU.Server.Settings.MaxRecentLoot ==  0, func = function() LootReserveHoU.Server.Settings.MaxRecentLoot =  0; LootReserveHoU:ReopenMenu(self, "#recentSettings", "#max"); end },
													{ text =  "5", checked = LootReserveHoU.Server.Settings.MaxRecentLoot ==  5, func = function() LootReserveHoU.Server.Settings.MaxRecentLoot =  5; LootReserveHoU:ReopenMenu(self, "#recentSettings", "#max"); end },
													{ text = "10", checked = LootReserveHoU.Server.Settings.MaxRecentLoot == 10, func = function() LootReserveHoU.Server.Settings.MaxRecentLoot = 10; LootReserveHoU:ReopenMenu(self, "#recentSettings", "#max"); end },
													{ text = "15", checked = LootReserveHoU.Server.Settings.MaxRecentLoot == 15, func = function() LootReserveHoU.Server.Settings.MaxRecentLoot = 15; LootReserveHoU:ReopenMenu(self, "#recentSettings", "#max"); end },
													{ text = "20", checked = LootReserveHoU.Server.Settings.MaxRecentLoot == 20, func = function() LootReserveHoU.Server.Settings.MaxRecentLoot = 20; LootReserveHoU:ReopenMenu(self, "#recentSettings", "#max"); end },
													{ text = "25", checked = LootReserveHoU.Server.Settings.MaxRecentLoot == 25, func = function() LootReserveHoU.Server.Settings.MaxRecentLoot = 25; LootReserveHoU:ReopenMenu(self, "#recentSettings", "#max"); end },
													{ text = "30", checked = LootReserveHoU.Server.Settings.MaxRecentLoot == 30, func = function() LootReserveHoU.Server.Settings.MaxRecentLoot = 30; LootReserveHoU:ReopenMenu(self, "#recentSettings", "#max"); end },
													{ text = "35", checked = LootReserveHoU.Server.Settings.MaxRecentLoot == 35, func = function() LootReserveHoU.Server.Settings.MaxRecentLoot = 35; LootReserveHoU:ReopenMenu(self, "#recentSettings", "#max"); end },
													{ text = "40", checked = LootReserveHoU.Server.Settings.MaxRecentLoot == 40, func = function() LootReserveHoU.Server.Settings.MaxRecentLoot = 40; LootReserveHoU:ReopenMenu(self, "#recentSettings", "#max"); end },
													{ text = "45", checked = LootReserveHoU.Server.Settings.MaxRecentLoot == 45, func = function() LootReserveHoU.Server.Settings.MaxRecentLoot = 45; LootReserveHoU:ReopenMenu(self, "#recentSettings", "#max"); end },
													{ text = "50", checked = LootReserveHoU.Server.Settings.MaxRecentLoot == 50, func = function() LootReserveHoU.Server.Settings.MaxRecentLoot = 50; LootReserveHoU:ReopenMenu(self, "#recentSettings", "#max"); end },
												} },
												{ text = format("Minimum Item Quality: |cFF00FF00%s|r", LootReserveHoU.Constants.ItemQuality[LootReserveHoU.Server.Settings.MinimumLootQuality]), arg1 = "#quality", menuList = {
													{ text = LootReserveHoU.Constants.ItemQuality[-1], checked = LootReserveHoU.Server.Settings.MinimumLootQuality == -1, func = function() LootReserveHoU.Server.Settings.MinimumLootQuality = -1; LootReserveHoU:ReopenMenu(self, "#recentSettings", "#quality"); end },
													{ text = LootReserveHoU.Constants.ItemQuality[ 1], checked = LootReserveHoU.Server.Settings.MinimumLootQuality == 1 , func = function() LootReserveHoU.Server.Settings.MinimumLootQuality =  1; LootReserveHoU:ReopenMenu(self, "#recentSettings", "#quality"); end },
													{ text = LootReserveHoU.Constants.ItemQuality[ 2], checked = LootReserveHoU.Server.Settings.MinimumLootQuality == 2 , func = function() LootReserveHoU.Server.Settings.MinimumLootQuality =  2; LootReserveHoU:ReopenMenu(self, "#recentSettings", "#quality"); end },
													{ text = LootReserveHoU.Constants.ItemQuality[ 3], checked = LootReserveHoU.Server.Settings.MinimumLootQuality == 3 , func = function() LootReserveHoU.Server.Settings.MinimumLootQuality =  3; LootReserveHoU:ReopenMenu(self, "#recentSettings", "#quality"); end },
													{ text = LootReserveHoU.Constants.ItemQuality[ 4], checked = LootReserveHoU.Server.Settings.MinimumLootQuality == 4 , func = function() LootReserveHoU.Server.Settings.MinimumLootQuality =  4; LootReserveHoU:ReopenMenu(self, "#recentSettings", "#quality"); end },
													{ text = LootReserveHoU.Constants.ItemQuality[99], checked = LootReserveHoU.Server.Settings.MinimumLootQuality == 99, func = function() LootReserveHoU.Server.Settings.MinimumLootQuality = 99; LootReserveHoU:ReopenMenu(self, "#recentSettings", "#quality"); end },
												} },
												{
													text = "Remove Items After Rolling",
													tooltipText = "Remove the item from Recent Loot after it has been successfully rolled out.",
													checked = function() return LootReserveHoU.Server.Settings.RemoveRecentLootAfterRolling end,
													func = function(_, _, _, checked) LootReserveHoU.Server.Settings.RemoveRecentLootAfterRolling = checked; end,
												},
											} },
											{
												text = "Clear Blacklist",
												tooltipText = "Clear all items blocked from Recent Loot.|n|nHint:|nShift-Click an item to forget it.|nControl-Click an item to block it.",
												func = function() StaticPopup_Show("LootReserveHoU_CONFIRM_CLEAR_RECENT_LOOT_BLACKLIST"); end,
											},
											{ text = "Cancel" },
										};
										for bag, bagMenu in ipairs(bagMenus) do
											table.insert(menu, 3 + bag,
											{
												text = bag == 1 and "Backpack" or format("Bag %d", bag - 1),
												menuList = bagMenu,
											});
										end
										local currentLootOffset = 0;
										local recentLootBlocks = { };
										if GetNumLootItems() > 0 then
											for i = 1, GetNumLootItems() do
												local itemID = GetLootSlotInfo(i);
												if itemID then
			                    local itemLink = GetLootSlotLink(i);
			                    if itemLink and itemLink:find("item:%d") then -- GetLootSlotLink() sometimes returns "|Hitem:::::::::70:::::::::[]"
														local item = LootReserveHoU.ItemCache:Item(itemLink);
														if not LootReserveHoU.Server.Settings.RecentLootBlacklist[item:GetID()] and not LootReserveHoU.Data.RecentLootBlacklist[item:GetID()] then
															if currentLootOffset == 0 then
																table.insert(menu, 1, { text = "Current Loot", isTitle = true });
																table.insert(menu, 2, LootReserveHoU:MakeMenuSeparator());
																currentLootOffset = currentLootOffset + 2;
															end
															local texture, name, count = GetLootSlotInfo(i);
															table.insert(menu, currentLootOffset, MakeItem(count, item, texture));
															currentLootOffset = currentLootOffset + 1;
															recentLootBlocks[item] = recentLootBlocks[item] and recentLootBlocks[item] + 1 or 1;
														end
													end
												end
											end
										end
										local numRecentLootItems = 0;
										local recentLootItemsDone = { };
										for _, item in ipairs(LootReserveHoU.Server.RecentLoot) do
											if IsMasterLooter() and recentLootBlocks[item] and recentLootBlocks[item] > 0 then
												recentLootBlocks[item] = recentLootBlocks[item] - 1;
											elseif not recentLootItemsDone[item] then
												recentLootItemsDone[item] = true;
												local button = MakeItem(1, item);
												local count = LootReserveHoU:TableCount(LootReserveHoU.Server.RecentLoot, item);
												if count > 1 then
													button.text = button.text .. format(" |cFFFFFFFFx%s|r ", count);
												end
												local count = LootReserveHoU:GetTradeableItemCount(item:GetID());
												if count > 0 then
													button.text = button.text .. format(" |cFFC0C0C0(%d in bags)|r", count);
												end
												table.insert(menu, 2 + currentLootOffset, button);
												numRecentLootItems = numRecentLootItems + 1;
											end
										end
										if numRecentLootItems == 0 then
											table.insert(menu, 2 + currentLootOffset, { text = "No Loot", disabled = true });
										end
										LootReserveHoU:OpenMenu(menu, self:GetParent().Menu, self);

										if #missing > 0 then
											LootReserveHoU.ItemCache:OnCache(missing, function()
												if UIDROPDOWNMENU_OPEN_MENU == self:GetParent().Menu and not CursorHasItem() and not frame.Item then
													CloseMenus();
													self:DropHandler();
												end
											end);
										end
									end
								end
								self.TooltipHandler = function(self, show)
									if show then
										local frame = self:GetParent():GetParent();
										if frame.Item and not CursorHasItem() then
											self.CancelIcon:Show();
										else
											self.CancelIcon:Hide();
										end
										self.Arrow:SetShown(not frame.Item);
										GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
										if frame.Item then
											GameTooltip:SetHyperlink(self:GetParent():GetParent().Item:GetString());
										else
											GameTooltip:SetText("Drop an item here");
											GameTooltip:AddLine("Or click to select among relevant items", HIGHLIGHT_FONT_COLOR.r, HIGHLIGHT_FONT_COLOR.g, HIGHLIGHT_FONT_COLOR.b, 1, 1);
										end
										GameTooltip:Show();
									else
										GameTooltip_Hide(self);
										self.CancelIcon:Hide();
										self.Arrow:Hide();
									end
								end
							</OnLoad>
							<OnClick>
								self:DropHandler();
								self:TooltipHandler(GameTooltip:IsShown());
							</OnClick>
							<!--OnDragStart>
								self:DropHandler();
							</OnDragStart-->
							<OnReceiveDrag>
								self:DropHandler();
							</OnReceiveDrag>
							<OnEnter>
								self:TooltipHandler(true);
							</OnEnter>
							<OnLeave>
								self:TooltipHandler(false);
							</OnLeave>
						</Scripts>
					</Button>
					<Frame parentKey="Menu" inherits="UIDropDownMenuTemplate" hidden="true" />
				</Frames>
				<Layers>
					<Layer>
						<FontString parentKey="Name" inherits="GameFontNormalLarge" justifyH="LEFT" wordwrap="true" maxLines="0" mixin="AutoScalingFontStringMixin">
							<KeyValues>
								<KeyValue key="minLineHeight" value="10" type="number"/>
							</KeyValues>
							<Size y="20" />
							<Anchors>
								<Anchor point="TOPLEFT" relativeKey="$parent.Icon" relativePoint="TOPRIGHT" x="5" />
								<Anchor point="TOPRIGHT" />
							</Anchors>
						</FontString>
						<FontString parentKey="Misc" inherits="GameFontNormalGraySmall" justifyH="LEFT" wordwrap="false" mixin="AutoScalingFontStringMixin">
							<KeyValues>
								<KeyValue key="minLineHeight" value="8" type="number"/>
							</KeyValues>
							<Size y="12" />
							<Anchors>
								<Anchor point="TOPLEFT" relativeKey="$parent.Name" relativePoint="BOTTOMLEFT" />
								<Anchor point="BOTTOMRIGHT" />
							</Anchors>
						</FontString>
					</Layer>
				</Layers>
				<Scripts>
					<OnLoad>
						self.Icon.SetTexture = function(self, texture)
							self.Texture:SetTexture(texture);
						end
					</OnLoad>
					<OnClick>
						if button == "LeftButton" then
							HandleModifiedItemClick(self:GetParent().Link);
						end
					</OnClick>
					<OnSizeChanged>
						self.Name:ScaleTextToFit();
						self.Misc:ScaleTextToFit();
					</OnSizeChanged>
				</Scripts>
			</Button>
			<Frame name="LootReserveHoURollFakeMasterLoot" hidden="true">
				<Size x="0" y="0" />
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.ItemFrame" relativePoint="BOTTOMLEFT" />
				</Anchors>
				<Layers>
					<Layer>
						<FontString name="$parentText" parentKey="Text" inherits="GameFontNormal" hidden="true" />
						<Texture name="$parentIconTexture" parentKey="IconTexture" hidden="true" />
					</Layer>
				</Layers>
			</Frame>
		</Frames>
		<Scripts>
			<OnLoad inherit="prepend">
				self.SetItem = function(self, item)
					if item then
						item = LootReserveHoU.ItemCache:Item(item);
						self.Item = item;

						local name, link, texture = item:GetNameLinkTexture();
						self.Link = link;

						if not name or not link then
							item:OnCache(function()
								if self.Item == item then
									self:SetItem(item);
								end
							end);
							return;
						end

            local token;
            if not LootReserveHoU.Server.ReservableIDs[item:GetID()] and LootReserveHoU.Server.ReservableRewardIDs[item:GetID()] then
                token = LootReserveHoU.ItemCache:Item(LootReserveHoU.Data:GetToken(item:GetID())) or LootReserveHoU.ItemCache:Item(LootReserveHoU.Data:GetToken(item:GetID()));
            end
						local reservers = 0;
						if LootReserveHoU.Server.CurrentSession then
							if LootReserveHoU.Server.CurrentSession.ItemReserves[token and token:GetID() or item:GetID()] then
								local _, _, uniquePlayers = LootReserveHoU:GetReservesData(LootReserveHoU.Server.CurrentSession.ItemReserves[token and token:GetID() or item:GetID()].Players);
								reservers = uniquePlayers;
							end
						end

						self.ItemFrame.Icon:SetTexture(texture);
						--self.ItemFrame.Icon.CancelIcon:SetShown(GameTooltip:IsOwned(self.ItemFrame.Icon)); -- Looks better without it
						self.ItemFrame.Icon.Arrow:Hide();
						self.ItemFrame.Name:SetText((link or name or "|cFFFF4000Loading...|r"):gsub("[%[%]]", ""));
						self.ItemFrame.Misc:SetText(LootReserveHoU:GetTradeableItemCount(item) &lt; 1 and not LootReserveHoU:IsLootingItem(item) and "|cFFFF0000Cannot distribute|r" or reservers > 0 and format("Reserved by %d |4player:players;", reservers) or "Not reserved");
						self.RequestRollButton:Show();
						self.RequestRollButton:SetWidth(32);
					else
						self.Item = nil;
						self.Link = nil;
						self.ItemFrame.Icon:SetTexture(nil);
						self.ItemFrame.Icon.CancelIcon:Hide();
						self.ItemFrame.Icon.Arrow:SetShown(self.ItemFrame.Icon:IsMouseOver());
						self.ItemFrame.Name:SetText("|cFF808080Drop an Item|r");
						self.ItemFrame.Misc:SetText("or click to select");
						self.RequestRollButton:Hide();
						self.RequestRollButton:SetWidth(0.00001);
					end
				end
				self:SetItem(nil);
			</OnLoad>
		</Scripts>
	</Frame>
	<Frame name="LootReserveHoURollHistoryHeader" virtual="true" enableMouse="true">
		<Size y="16" />
		<Layers>
			<Layer>
				<FontString text="History" inherits="GameFontNormalSmall" setAllPoints="true" />
			</Layer>
		</Layers>
		<Frames>
			<Frame parentKey="Menu" inherits="UIDropDownMenuTemplate" hidden="true" />
			<Button parentKey="MenuButton">
				<Size x="12" y="12" />
				<Anchors>
					<Anchor point="RIGHT" x="-2" />
				</Anchors>
				<NormalTexture file="Interface\Buttons\UI-OptionsButton" />
				<PushedTexture file="Interface\Buttons\UI-OptionsButton" alpha="0.25" />
				<HighlightTexture file="Interface\Buttons\UI-OptionsButton" alphaMode="ADD" alpha="0.5" />
				<Scripts>
					<OnClick>
						local menu =
						{
							{
								text = "Hide Empty Rolls",
								func = function(info)
									LootReserveHoU.Server.Settings.RollHistoryHideEmpty = not LootReserveHoU.Server.Settings.RollHistoryHideEmpty;
									LootReserveHoU.Server:UpdateRollList();
								end,
								checked = function(info)
									return LootReserveHoU.Server.Settings.RollHistoryHideEmpty;
								end,
								tooltipText = "Items without rolls will be hidden from view. They will still be kept in the history.",
							},
							{
								text = "Hide Distributed Rolls",
								func = function(info)
									LootReserveHoU.Server.Settings.RollHistoryHideNotOwed = not LootReserveHoU.Server.Settings.RollHistoryHideNotOwed;
									LootReserveHoU.Server:UpdateRollList();
								end,
								checked = function(info)
									return LootReserveHoU.Server.Settings.RollHistoryHideNotOwed;
								end,
								tooltipText = "Items that have been distributed will be hidden from view. They will still be kept in the history.",
							},
							LootReserveHoU:MakeMenuSeparator(),
							{ text = "Display Limit", isTitle = true },
							LootReserveHoU:MakeMenuSeparator(),
							{ text = "History Limit", isTitle = true },
							LootReserveHoU:MakeMenuSeparator(),
							{ text = "Export History", func = function()
								LootReserveHoU.Server.Export.Window:SetShown(not LootReserveHoU.Server.Export.Window:IsShown());
							end },
							{ text = "Clear History", func = function()
								StaticPopup_Show("LootReserveHoU_CONFIRM_CLEAR_HISTORY", #LootReserveHoU.Server.RollHistory, #LootReserveHoU.Server.RollHistory == 1 and "" or "s");
							end },
							LootReserveHoU:MakeMenuSeparator(),
							{ text = "Close" },
						};
						for i, limit in ipairs({ 100, 250, 500, 1000, 10000 }) do
							table.insert(menu, 6 + i,
							{
								text = format("%d |4roll:rolls;", limit),
								arg1 = limit,
								func = function(info, limit)
									LootReserveHoU.Server.Settings.RollHistoryKeepLimit = limit;
									
									if #LootReserveHoU.Server.RollHistory > LootReserveHoU.Server.Settings.RollHistoryKeepLimit then
										wipe(LootReserveHoU.Server.OwedRolls);
										local delta = #LootReserveHoU.Server.RollHistory - LootReserveHoU.Server.Settings.RollHistoryKeepLimit;
										for i = 1, LootReserveHoU.Server.Settings.RollHistoryKeepLimit do
											LootReserveHoU.Server.RollHistory[i] = LootReserveHoU.Server.RollHistory[i + delta];
											if LootReserveHoU.Server.RollHistory[i].Owed then
												table.insert(LootReserveHoU.Server.OwedRolls, LootReserveHoU.Server.RollHistory[i]);
											end
										end
										for i = #LootReserveHoU.Server.RollHistory, LootReserveHoU.Server.Settings.RollHistoryKeepLimit + 1, -1 do
											LootReserveHoU.Server.RollHistory[i] = nil;
										end
									end
									LootReserveHoU.Server:UpdateRollList();
									LootReserveHoU:ReopenMenu(self);
								end,
								checked = LootReserveHoU.Server.Settings.RollHistoryKeepLimit == limit,
							});
						end
						for i, limit in ipairs({ 5, 10, 25, 50, 100 }) do
							table.insert(menu, 4 + i,
							{
								text = format("%d |4roll:rolls;", limit),
								arg1 = limit,
								func = function(info, limit)
									LootReserveHoU.Server.Settings.RollHistoryDisplayLimit = limit;
									LootReserveHoU.Server.RollHistoryDisplayLimit = limit;
									LootReserveHoU.Server:UpdateRollList();
									LootReserveHoU:ReopenMenu(self);
								end,
								checked = LootReserveHoU.Server.Settings.RollHistoryDisplayLimit == limit,
							});
						end
						LootReserveHoU:OpenMenu(menu, self:GetParent().Menu, self);
					</OnClick>
				</Scripts>
			</Button>
		</Frames>
		<Scripts>
			<OnUpdate>
				if self:IsProtected() and InCombatLockdown() then return; end
				<!-- self.MenuButton:SetShown(self:IsMouseOver() or UIDROPDOWNMENU_OPEN_MENU == self.Menu); -->
			</OnUpdate>
		</Scripts>
	</Frame>
	<Frame name="LootReserveHoURollHistoryShowMore" virtual="true" enableMouse="true">
		<Size y="32" />
		<Frames>
			<Button parentKey="Button" inherits="UIMenuButtonStretchTemplate">
				<Size x="100" y="24" />
				<Anchors>
					<Anchor point="CENTER" />
				</Anchors>
				<Scripts>
					<OnClick>
						LootReserveHoU.Server.RollHistoryDisplayLimit = LootReserveHoU.Server.RollHistoryDisplayLimit + LootReserveHoU.Server.Settings.RollHistoryDisplayLimit;
						LootReserveHoU.Server:UpdateRollList();
					</OnClick>
				</Scripts>
			</Button>
		</Frames>
	</Frame>
	<Frame name="LootReserveHoUServerWindow" inherits="BasicFrameTemplateWithInset" parent="UIParent" toplevel="true" movable="true" resizable="true" enableMouse="true" clampedToScreen="true" hidden="true">
		<Size x="230" y="360" />
		<Anchors>
			<Anchor point="CENTER" />
		</Anchors>
		<Frames>
			<Button inherits="LootReserveHoUCommonFrameMovingHeaderTemplate" />
			<Button inherits="LootReserveHoUCommonFrameSizeGrabberTemplate" />
			<Button inherits="LootReserveHoUSettingsButtonTemplate">
				<Scripts>
					<OnClick>
						local function GetSettingContainerAndKey(setting)
							if type(setting) == "table" then
								local container = LootReserveHoU.Server.Settings;
								for i, key in ipairs(setting) do
									if i == #setting then
										return container, key;
									else
										container = container[key];
									end
								end
							else
								return LootReserveHoU.Server.Settings, setting;
							end
						end
						local function GetValue(setting)
							local container, key = GetSettingContainerAndKey(setting);
							return container[key];
						end
						local function SetValue(setting, value)
							local container, key = GetSettingContainerAndKey(setting);
							container[key] = value;
							return value;
						end

						-- Buttons
						local function MakeMenuItem(text, setting, tooltip, checked, func)
							return
							{
								text = text,
								arg1 = setting,
								func = func,
								checked = checked,
								tooltipText = tooltip,
								DisableIf = function(self, condition) self.disabled = condition; return self; end,
							};
						end
						local function MakeMenuToggle(text, setting, tooltip, callback)
							return MakeMenuItem(text, setting, tooltip,
								function(info)
									return GetValue(setting);
								end,
								function(info)
									local value = SetValue(setting, not GetValue(setting));
									if callback then
										callback(value);
									end
								end);
						end
						local function MakeMenuRadio(text, setting, value, tooltip, callback)
							return MakeMenuItem(text, setting, tooltip,
								function(info)
									return GetValue(setting) == value;
								end,
								function(info)
									value = SetValue(setting, value);
									if callback then
										callback(value);
									end
								end);
						end

						-- Callbacks
						local function RefreshReservesSorting()
							LootReserveHoU.Server:UpdateReserveList();
							LootReserveHoU:ReopenMenu(self, "#sort");
						end
						local function RefreshWinToGuildThreshold()
							LootReserveHoU:ReopenMenu(self, "#guild");
						end
						local function RefreshChatReservesLimit()
							LootReserveHoU:ReopenMenu(self, "#chatReservesLimit");
						end
						local function RefreshRolls()
							LootReserveHoU.Server:UpdateRollList();
						end
						local function ToggleUseUnitFrames(enabled)
							if enabled then
								if not InCombatLockdown() then
									LootReserveHoU.Server.OnExitCombat();
								end
							else
								if not InCombatLockdown() then
									LootReserveHoU.Server.OnEnterCombat();
								end
								StaticPopup_Show("LootReserveHoU_RELOAD_UI", "A UI reload is required for this to take full effect.");
							end
						end
						local function ToggleGlobalProfile(enabled)
							if enabled then
								LootReserveHoU.Server.Settings.UseGlobalProfile = false;
								LootReserveHoU:ReopenMenu(self);
								StaticPopup_Show("LootReserveHoU_CONFIRM_GLOBAL_PROFILE_ENABLE");
							else
								LootReserveHoU.Server.Settings.UseGlobalProfile = true;
								LootReserveHoU:ReopenMenu(self);
								StaticPopup_Show("LootReserveHoU_CONFIRM_GLOBAL_PROFILE_DISABLE");
							end
						end
						local function ToggleAcceptAllRollFormats(enabled)
							if enabled then
								LootReserveHoU.Server.Settings.AcceptAllRollFormats = false;
								LootReserveHoU:ReopenMenu(self);
								StaticPopup_Show("LootReserveHoU_ACCEPT_ALL_ROLL_FORMATS_ENABLE");
							else
								LootReserveHoU.Server.Settings.AcceptAllRollFormats = false;
							end
						end
						local function RefreshWinnerReservesRemoval()
							LootReserveHoU:ReopenMenu(self, "#reservesRemoval");
						end

						local function MakeChatColoredText(text, chatType)
							local info = ChatTypeInfo[chatType or "RAID_WARNING"];
							return format("|cff%02x%02x%02x%s|r", info.r * 255, info.g * 255, info.b * 255, text);
						end
						local function MakeRaidWarningTooltip(when)
							return format("Enable to broadcast to %s instead of %s %s.|n|nWill still be announced to %s if you have no permissions to speak in %s, or to %s if not in a raid group.",
								MakeChatColoredText("/rw", "RAID_WARNING"),
								MakeChatColoredText("/raid", "RAID"),
								when,
								MakeChatColoredText("/raid", "RAID"),
								MakeChatColoredText("/rw", "RAID_WARNING"),
								MakeChatColoredText("/party", "PARTY"));
						end

						local menu =
						{
							{ text = "Communications", isTitle = true },
							{ text = format("Announce to %s...", MakeChatColoredText("/rw", "RAID_WARNING")), menuList = {
								MakeMenuToggle("Reserves Started",              { "ChatAsRaidWarning", LootReserveHoU.Constants.ChatAnnouncement.SessionStart              }, MakeRaidWarningTooltip("when starting to accept reserves")),
								MakeMenuToggle("Reserves Resumed",              { "ChatAsRaidWarning", LootReserveHoU.Constants.ChatAnnouncement.SessionResume             }, MakeRaidWarningTooltip("when resuming reserves")),
								MakeMenuToggle("Reserves Stopped",              { "ChatAsRaidWarning", LootReserveHoU.Constants.ChatAnnouncement.SessionStop               }, MakeRaidWarningTooltip("when stopping reserves")),
								MakeMenuToggle("Blind Reserves Toggled",        { "ChatAsRaidWarning", LootReserveHoU.Constants.ChatAnnouncement.SessionBlindToggle        }, MakeRaidWarningTooltip("when enabling or disabling blind reserves")),
								MakeMenuToggle("Announce Instructions",         { "ChatAsRaidWarning", LootReserveHoU.Constants.ChatAnnouncement.SessionInstructions       }, MakeRaidWarningTooltip("when manually announcing reserve instructions")),
								MakeMenuToggle("Announce Reserves",             { "ChatAsRaidWarning", LootReserveHoU.Constants.ChatAnnouncement.SessionReserves           }, MakeRaidWarningTooltip("when manually announcing reserves")),
								MakeMenuToggle("Roll on an Item",               { "ChatAsRaidWarning", LootReserveHoU.Constants.ChatAnnouncement.RollStartCustom           }, MakeRaidWarningTooltip("when starting an item roll")),
								MakeMenuToggle("Roll on a Reserved Item",       { "ChatAsRaidWarning", LootReserveHoU.Constants.ChatAnnouncement.RollStartReserved         }, MakeRaidWarningTooltip("when starting a roll on a reserved item")),
								MakeMenuToggle("Roll Countdown",                { "ChatAsRaidWarning", LootReserveHoU.Constants.ChatAnnouncement.RollCountdown             }, MakeRaidWarningTooltip("when the roll timer is nearing its end (if countdown was enabled for this roll)")),
								MakeMenuToggle("Roll Winner",                   { "ChatAsRaidWarning", LootReserveHoU.Constants.ChatAnnouncement.RollWinner                }, MakeRaidWarningTooltip("when the rolled item is won by a player")),
								MakeMenuToggle("Roll Tie",                      { "ChatAsRaidWarning", LootReserveHoU.Constants.ChatAnnouncement.RollTie                   }, MakeRaidWarningTooltip("when a roll ended in a tie and tied players need to roll again")),
							} },
							{ text = format("Announce to %s...", MakeChatColoredText("/guild", "GUILD")), arg1 = "#guild", menuList = {
								MakeMenuToggle("Roll Winner", "ChatAnnounceWinToGuild", format("Broadcast to %s when the rolled item is won by a guild member.", MakeChatColoredText("/guild", "GUILD")), RefreshWinToGuildThreshold),
								LootReserveHoU:MakeMenuSeparator(),
								{ text = "Quality Threshold", isTitle = true, disabled = not LootReserveHoU.Server.Settings.ChatAnnounceWinToGuild },
								MakeMenuRadio(LootReserveHoU.Server.Settings.ChatAnnounceWinToGuild and format("%s%s|r", ITEM_QUALITY_COLORS[4].hex, ITEM_QUALITY4_DESC) or ITEM_QUALITY4_DESC, "ChatAnnounceWinToGuildThreshold", 4, nil, RefreshWinToGuildThreshold):DisableIf(not LootReserveHoU.Server.Settings.ChatAnnounceWinToGuild),
								MakeMenuRadio(LootReserveHoU.Server.Settings.ChatAnnounceWinToGuild and format("%s%s|r", ITEM_QUALITY_COLORS[3].hex, ITEM_QUALITY3_DESC) or ITEM_QUALITY3_DESC, "ChatAnnounceWinToGuildThreshold", 3, nil, RefreshWinToGuildThreshold):DisableIf(not LootReserveHoU.Server.Settings.ChatAnnounceWinToGuild),
								MakeMenuRadio(LootReserveHoU.Server.Settings.ChatAnnounceWinToGuild and format("%s%s|r", ITEM_QUALITY_COLORS[2].hex, ITEM_QUALITY2_DESC) or ITEM_QUALITY2_DESC, "ChatAnnounceWinToGuildThreshold", 2, nil, RefreshWinToGuildThreshold):DisableIf(not LootReserveHoU.Server.Settings.ChatAnnounceWinToGuild),
								MakeMenuRadio(LootReserveHoU.Server.Settings.ChatAnnounceWinToGuild and format("%s%s|r", ITEM_QUALITY_COLORS[1].hex, ITEM_QUALITY1_DESC) or ITEM_QUALITY1_DESC, "ChatAnnounceWinToGuildThreshold", 1, nil, RefreshWinToGuildThreshold):DisableIf(not LootReserveHoU.Server.Settings.ChatAnnounceWinToGuild),
								MakeMenuRadio(LootReserveHoU.Server.Settings.ChatAnnounceWinToGuild and format("%s%s|r", ITEM_QUALITY_COLORS[0].hex, ITEM_QUALITY0_DESC) or ITEM_QUALITY0_DESC, "ChatAnnounceWinToGuildThreshold", 0, nil, RefreshWinToGuildThreshold):DisableIf(not LootReserveHoU.Server.Settings.ChatAnnounceWinToGuild),
							} },
							MakeMenuToggle("Enable !reserves command", "ChatReservesList",  "Allow players to request currently made reserves to be whispered back to them when they invoke the  |cFFFFFFFF!reserves|r or |cFFFFFFFF!myreserves|r commands.|n|n|cFFFF2020Warning|r: Can result in slow chat messages.|n|nReduce chat lag by limiting the number of reserves that |cFFFFFFFF!reserves|r can send at once. The |cFFFFFFFF!myreserves|r command will always send all of the player's reserves."),
							{ text = format("Limit !reserves response: |cFF00FF00%s|r", LootReserveHoU.Constants.ChatReservesListLimitText[LootReserveHoU.Server.Settings.ChatReservesListLimit] or LootReserveHoU.Server.Settings.ChatReservesListLimit), arg1 = "#chatReservesLimit", menuList = {
								MakeMenuRadio("1",  "ChatReservesListLimit", 1,  nil, RefreshChatReservesLimit),
								MakeMenuRadio("2",  "ChatReservesListLimit", 2,  nil, RefreshChatReservesLimit),
								MakeMenuRadio("3",  "ChatReservesListLimit", 3,  nil, RefreshChatReservesLimit),
								MakeMenuRadio("5",  "ChatReservesListLimit", 5,  nil, RefreshChatReservesLimit),
								MakeMenuRadio("10", "ChatReservesListLimit", 10, nil, RefreshChatReservesLimit),
								MakeMenuRadio("20", "ChatReservesListLimit", 20, nil, RefreshChatReservesLimit),
								MakeMenuRadio("30", "ChatReservesListLimit", 30, nil, RefreshChatReservesLimit),
								MakeMenuRadio("40", "ChatReservesListLimit", 40, nil, RefreshChatReservesLimit),
								MakeMenuRadio(LootReserveHoU.Constants.ChatReservesListLimitText[LootReserveHoU.Constants.ChatReservesListLimit.None], "ChatReservesListLimit", LootReserveHoU.Constants.ChatReservesListLimit.None, nil, RefreshChatReservesLimit),
							} },
							
							MakeMenuToggle("Whisper Reserve Updates",     "ChatUpdates",       "Send whispers to players without addons if someone else reserves or cancels the reserve of the items that they have reserved as well."),
							LootReserveHoU:MakeMenuSeparator(),
							{ text = "Display", isTitle = true },
							{ text = format("Sort Reserves: |cFF00FF00%s|r", LootReserveHoU.Constants.ReservesSortingText[LootReserveHoU.Server.Settings.ReservesSorting] or "???"), arg1 = "#sort", menuList = {
								MakeMenuRadio(LootReserveHoU.Constants.ReservesSortingText[LootReserveHoU.Constants.ReservesSorting.ByTime  ], "ReservesSorting", LootReserveHoU.Constants.ReservesSorting.ByTime,   "Sort reserves by the time the item was first reserved in the current session.", RefreshReservesSorting),
								MakeMenuRadio(LootReserveHoU.Constants.ReservesSortingText[LootReserveHoU.Constants.ReservesSorting.ByName  ], "ReservesSorting", LootReserveHoU.Constants.ReservesSorting.ByName,   "Sort reserves by the name of the item.", RefreshReservesSorting),
								MakeMenuRadio(LootReserveHoU.Constants.ReservesSortingText[LootReserveHoU.Constants.ReservesSorting.BySource], "ReservesSorting", LootReserveHoU.Constants.ReservesSorting.BySource, "Sort reserves by the order of the boss the item first drops from.", RefreshReservesSorting),
								MakeMenuRadio(LootReserveHoU.Constants.ReservesSortingText[LootReserveHoU.Constants.ReservesSorting.ByLooter], "ReservesSorting", LootReserveHoU.Constants.ReservesSorting.ByLooter, "Sort reserves by the name of one of the players that looted this item in the current session.|n|nFade out items not looted by anyone.|cFF808080 (applies only after some items have been looted in the raid)|r", RefreshReservesSorting),
							} },
							MakeMenuToggle("Use Unit Frames", "UseUnitFrames", "Make player rows in Reserves and Rolls tabs behave like unit frames, allowing them to be right-clicked for context menu, have items be dropped on them to open trade etc.|n|nOnly works outside of combat.|n|nWhen enabled, this may prevent the host window from being closed and reopened while in combat via minimap button or |cFFFFFFFF/reserve host|r command.", ToggleUseUnitFrames),
							MakeMenuToggle("Show Reopen Hint", "ShowReopenHint", "Shows a hint in chat when this window is closed, telling you how to reopen it."),
							MakeMenuToggle("24 Hour Clock", "Use24HourTime", "Shows and broadcasts times using a 24 hour format. Disable for 12 hour formatting.", RefreshRolls),
							LootReserveHoU:MakeMenuSeparator(),
							{ text = "Rolls", isTitle = true },
							MakeMenuToggle("Accept All Roll Formats", "AcceptAllRollFormats", "If enabled, custom rolls will be honored. If disabled, only 1-100 rolls will be considered and all others will be ignored.", ToggleAcceptAllRollFormats),
							{ text = format("Remove winners' reserves: |cFF00FF00%s|r", LootReserveHoU.Constants.WinnerReservesRemovalText[LootReserveHoU.Server.Settings.WinnerReservesRemoval] or "???"), arg1 = "#reservesRemoval", menuList = {
								MakeMenuRadio(LootReserveHoU.Constants.WinnerReservesRemovalText[LootReserveHoU.Constants.WinnerReservesRemoval.None], "WinnerReservesRemoval", LootReserveHoU.Constants.WinnerReservesRemoval.None, "Don't adjust reserves when a reserved item is won.", RefreshWinnerReservesRemoval),
								MakeMenuRadio(LootReserveHoU.Constants.WinnerReservesRemovalText[LootReserveHoU.Constants.WinnerReservesRemoval.Single], "WinnerReservesRemoval", LootReserveHoU.Constants.WinnerReservesRemoval.Single, "When a reserver wins a reserved item, remove one of the winner's reserves on that item.", RefreshWinnerReservesRemoval),
								MakeMenuRadio(LootReserveHoU.Constants.WinnerReservesRemovalText[LootReserveHoU.Constants.WinnerReservesRemoval.Smart], "WinnerReservesRemoval", LootReserveHoU.Constants.WinnerReservesRemoval.Smart, "If Usable is checked, default to Duplicate.|n|nIf Usable is not checked, default to Just One.|n|nUnder certain conditions when Usable is checked, Just One may be used instead. These conditions include winning a non-unique ring or a tradeable raid material.", RefreshWinnerReservesRemoval),
								MakeMenuRadio(LootReserveHoU.Constants.WinnerReservesRemovalText[LootReserveHoU.Constants.WinnerReservesRemoval.Duplicate], "WinnerReservesRemoval", LootReserveHoU.Constants.WinnerReservesRemoval.Duplicate, "When a reserver wins a reserved item, remove all of the winner's reserves on that item.", RefreshWinnerReservesRemoval),
								MakeMenuRadio(LootReserveHoU.Constants.WinnerReservesRemovalText[LootReserveHoU.Constants.WinnerReservesRemoval.All], "WinnerReservesRemoval", LootReserveHoU.Constants.WinnerReservesRemoval.All, "When a reserver wins a reserved item, remove all of the winner's reserves on every item.", RefreshWinnerReservesRemoval),
							} },
							LootReserveHoU:MakeMenuSeparator(),
							{ text = "Storage", isTitle = true },
							MakeMenuToggle("Use Global Profile", "UseGlobalProfile", "By default all the data about the active reserves session is stored per-character. Enable this to share the same session between all characters on your account.|n|nThe session from your current character will be the one propagated to others.", ToggleGlobalProfile),
								LootReserveHoU:MakeMenuSeparator(),
							{ text = "Close" },
						};
						LootReserveHoU:OpenMenu(menu, self.Menu, self);
					</OnClick>
				</Scripts>
			</Button>
			<StatusBar parentKey="Duration" inherits="LootReserveHoUDurationStatusBar">
				<KeyValues>
					<KeyValue key="server" value="true" type="boolean" />
				</KeyValues>
				<Size y="8" />
				<Anchors>
					<Anchor point="TOPLEFT" x="7" y="-27" />
					<Anchor point="TOPRIGHT" x="-10" y="-27" />
				</Anchors>
			</StatusBar>
			<EditBox parentKey="Search" inherits="SearchBoxTemplate">
				<Size y="20" />
				<Anchors>
					<Anchor point="TOPLEFT" x="10" y="-25" />
					<Anchor point="TOPRIGHT" x="-7" y="-25" />
				</Anchors>
				<Scripts>
					<OnLoad inherit="prepend">
						self.Instructions:SetText("Search items or players");
						self.Instructions:SetPoint("BOTTOMRIGHT", self, "BOTTOMRIGHT", -8, 0);
						self.Instructions:SetWordWrap(false);
					</OnLoad>
					<OnTextChanged inherit="prepend">
						LootReserveHoU.Server:UpdateReserveList();
						LootReserveHoU.Server:UpdateRollList();
					</OnTextChanged>
				</Scripts>
			</EditBox>
			<Button parentKey="ButtonMenu" inherits="UIMenuButtonStretchTemplate">
				<Size y="21" />
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.Search" relativePoint="TOPRIGHT" x="0" y="0" />
					<Anchor point="TOPRIGHT" relativeKey="$parent.Search" relativePoint="TOPRIGHT" x="80" y="0" />
				</Anchors>
				<Layers>
					<Layer>
						<Texture parentKey="Arrow" file="Interface\BUTTONS\UI-SortArrow">
							<Size x="8" y="8" />
							<Anchors>
								<Anchor point="RIGHT" x="-8" />
							</Anchors>
							<TexCoords left="0" right="0.5" top="0" bottom="1" />
						</Texture>
						<Texture parentKey="Icon" file="Interface\CHATFRAME\UI-ChatConversationIcon">
							<Size x="16" y="16" />
							<Anchors>
								<Anchor point="LEFT" x="6" />
							</Anchors>
						</Texture>
					</Layer>
				</Layers>
				<Scripts>
					<OnLoad>
						self:SetPushedTextOffset(1, -1);
						self:SetNormalFontObject(GameFontHighlightSmallLeft);
						self:SetHighlightFontObject(GameFontHighlightSmallLeft);
						self:SetDisabledFontObject(GameFontDisableSmallLeft);
						self.Text:ClearAllPoints();
						self.Text:SetPoint("LEFT", self, "LEFT", 8 + 16, 0);
						self.Text:SetPoint("RIGHT", self, "RIGHT", -8 - 8, 0);
						self.UpdateTooltip = function(self)
							local missingPlayers = { };
							if LootReserveHoU.Server.CurrentSession then
								for player, member in pairs(LootReserveHoU.Server.CurrentSession.Members) do
									if member.ReservesLeft > 0 and not member.OptedOut then
										local max = LootReserveHoU.Server.CurrentSession.Settings.MaxReservesPerPlayer + member.ReservesDelta;
										table.insert(missingPlayers, {Player = player, Reserves = max - member.ReservesLeft, Max = max});
									end
								end
							end
							GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
							GameTooltip:SetText(#missingPlayers == 0 and "|cFF00FF00All players reserved items|r" or format("%d |4player:players; missing reserves:", #missingPlayers));
							for _, data in LootReserveHoU:Ordered(missingPlayers, function(a, b) return a.Player &lt; b.Player; end) do
								GameTooltip:AddLine(format("|cFF%s[%d/%d] %s%s", data.Reserves == 0 and "FF0000" or "FF7700", data.Reserves, data.Max, LootReserveHoU:ColoredPlayer(data.Player), LootReserveHoU:IsPlayerOnline(data.Player) == nil and "|cFF808080 (not in raid)|r" or LootReserveHoU:IsPlayerOnline(data.Player) == false and "|cFF808080 (offline)|r" or ""));
							end
							GameTooltip:AddLine("Click for more options", GRAY_FONT_COLOR.r, GRAY_FONT_COLOR.g, GRAY_FONT_COLOR.b);
							GameTooltip:Show();
						end
					</OnLoad>
					<OnClick>
						local menuWhisperPlayers = { };
						if LootReserveHoU.Server.CurrentSession and LootReserveHoU.Server.CurrentSession.AcceptingReserves then
							for player, member in LootReserveHoU:Ordered(LootReserveHoU.Server.CurrentSession.Members, function(_, _, a, b) return a &lt; b end) do
								if member.ReservesLeft > 0 and not member.OptedOut then
									local max = LootReserveHoU.Server.CurrentSession.Settings.MaxReservesPerPlayer + member.ReservesDelta;
									local reserves = max - member.ReservesLeft;
									table.insert(menuWhisperPlayers,
									{
										text = format("|cFF%s[%d/%d] %s%s", reserves == 0 and "FF0000" or "FF7700", reserves, max, LootReserveHoU:ColoredPlayer(player), LootReserveHoU:IsPlayerOnline(player) == nil and "|cFF808080 (not in raid)|r" or LootReserveHoU:IsPlayerOnline(player) == false and "|cFF808080 (offline)|r" or ""),
										arg1 = player,
										func = function(info) LootReserveHoU.Server:WhisperPlayerWithoutReserves(info.arg1); LootReserveHoU:ReopenMenu(self, "#whisper"); end,
										tooltipTitle = "Send Automatic Whisper",
										tooltipText = format("Send an automatic whisper to %s to use %d |4outstanding reserve:outstanding reserves;", LootReserveHoU:ColoredPlayer(player), member.ReservesLeft),
									});
								end
							end
						end
						local menu =
						{
							{ text = "Players Missing Reserves", isTitle = true },
							{ text = "Remind All", disabled = #menuWhisperPlayers == 0, func = function() LootReserveHoU.Server:WhisperAllWithoutReserves(); end, tooltipText = "Send an automatic whisper to all players with outstanding reserves.|n|nWhispers will be sent very slowly to avoid being chat throttled.|n|nIf a lot players have outstanding reserves, try using Announce Instructions instead." },
							{ text = "Remind...", arg1 = "#whisper", menuList = menuWhisperPlayers, disabled = #menuWhisperPlayers == 0 },
							LootReserveHoU:MakeMenuSeparator(),
							{ text = "Misc", isTitle = true },
							{ text = "Announce Instructions", disabled = not LootReserveHoU.Server.CurrentSession or not LootReserveHoU.Server.CurrentSession.AcceptingReserves, func = function() LootReserveHoU.Server:BroadcastInstructions(); end, tooltipText = "Announce instructions to chat" },
							{ text = "Announce All Reserves", disabled = not LootReserveHoU.Server.CurrentSession, func = function() LootReserveHoU.Server:SendReservesList(); end, tooltipText = format("Announce all reserves to chat%s", LootReserveHoU.Server.CurrentSession.Settings.Blind and "|n|n|cFFFF0000Warning: Blind mode is on.|r" or "") },
							{ text = "View Players", func = function() LootReserveHoU.Server.MembersEdit.Window:SetShown(not LootReserveHoU.Server.MembersEdit.Window:IsShown()); end },
							LootReserveHoU:MakeMenuSeparator(),
							{ text = "Cancel" },
						};
						LootReserveHoU:OpenMenu(menu, self:GetParent().Menu, self);
					</OnClick>
					<OnMouseDown>
						local x, y = self:GetPushedTextOffset();
						self.Icon:SetPoint("LEFT", self, "LEFT", 6 + x, y);
						self.Arrow:SetPoint("RIGHT", self, "RIGHT", -8 + x, y);
					</OnMouseDown>
					<OnMouseUp>
						self.Icon:SetPoint("LEFT", self, "LEFT", 6, 0);
						self.Arrow:SetPoint("RIGHT", self, "RIGHT", -8, 0);
					</OnMouseUp>
					<OnEnter>
						self:UpdateTooltip();
					</OnEnter>
					<OnLeave function="GameTooltip_Hide" />
				</Scripts>
			</Button>
			<Frame parentKey="Menu" inherits="UIDropDownMenuTemplate" hidden="true" />
			<Button parentKey="TabSession" inherits="LootReserveHoUServerWindowTabTemplate" id="1" text="Setup">
				<Anchors>
					<Anchor point="BOTTOMLEFT" x="11" y="-31" />
				</Anchors>
			</Button>
			<Button parentKey="TabReserves" inherits="LootReserveHoUServerWindowTabTemplate" id="2" text="Reserves">
				<Anchors>
					<Anchor point="LEFT" relativeKey="$parent.TabSession" relativePoint="RIGHT" x="-15" />
				</Anchors>
			</Button>
			<Button parentKey="TabRolls" inherits="LootReserveHoUServerWindowTabTemplate" id="3" text="Rolls">
				<Anchors>
					<Anchor point="LEFT" relativeKey="$parent.TabReserves" relativePoint="RIGHT" x="-15" />
				</Anchors>
			</Button>
			<Frame parentKey="PanelSession" parentArray="Panels">
				<Anchors>
					<Anchor point="TOPLEFT" x="7" y="-27" />
					<Anchor point="BOTTOMRIGHT" x="-9" y="6" />
				</Anchors>
				<Layers>
					<Layer>
						<FontString parentKey="LabelTitle" inherits="GameFontNormalHuge3" text="LootReserveHoU">
							<Size y="20" />
							<Anchors>
								<Anchor point="TOP" y="-20" />
							</Anchors>
							<Color r="1" g="1" b="1" />
						</FontString>
						<FontString parentKey="LabelRaidSetup" inherits="GameFontNormalLarge" text="Raid Setup">
							<Size y="20" />
							<Anchors>
								<Anchor point="TOP" relativeKey="$parent.LabelTitle" relativePoint="BOTTOM" />
							</Anchors>
						</FontString>
						<FontString parentKey="LabelRaid" inherits="GameFontNormal" text="Select Raids">
							<Size y="20" />
							<Anchors>
								<Anchor point="TOP" relativeKey="$parent.LabelRaidSetup" relativePoint="BOTTOM" y="-20" />
							</Anchors>
						</FontString>
						<FontString parentKey="LabelCount" inherits="GameFontNormal" text="Reserves">
							<Size y="20" />
							<Anchors>
								<Anchor point="TOP" relativeKey="$parent.LabelRaid" relativePoint="BOTTOM" x="-45" y="-38" />
							</Anchors>
						</FontString>
						<FontString parentKey="LabelMultireserve" inherits="GameFontNormal" text="Multireserves">
							<Size y="20" />
							<Anchors>
								<Anchor point="TOP" relativeKey="$parent.LabelCount" relativePoint="BOTTOM" y="-30" />
							</Anchors>
						</FontString>
						<FontString parentKey="LabelDuration" inherits="GameFontNormal" text="Duration">
							<Size y="20" />
							<Anchors>
								<Anchor point="RIGHT" relativeKey="$parent" /> <!-- Adjusted in LootReserveHoU.Server:OnWindowLoad -->
							</Anchors>
						</FontString>
					</Layer>
				</Layers>
				<Frames>
					<Frame name="LootReserveHoUServerDropDownRaid" parentKey="DropDownRaid" inherits="UIDropDownMenuTemplate">
						<Size x="120" y="32" />
						<Anchors>
							<Anchor point="TOP" relativeKey="$parent.LabelRaid" relativePoint="BOTTOM" x="-30" />
						</Anchors>
						<Scripts>
							<OnLoad>
								self.UpdateText = function(self)
									UIDropDownMenu_SetText(self, LootReserveHoU:GetCategoriesText(LootReserveHoU.Server.NewSessionSettings.LootCategories, true));
								end
								self.init = function(self)
									self.init = nil;
									UIDropDownMenu_SetWidth(self, self:GetWidth());
									UIDropDownMenu_JustifyText(self, "LEFT");
									UIDropDownMenu_Initialize(self, function(frame, level, menuList)
										local info = UIDropDownMenu_CreateInfo();
										info.minWidth = self:GetWidth() - 40;
										info.isNotRadio = true;
										info.keepShownOnClick = true;
										info.func = function(info)
											if LootReserveHoU:Contains(LootReserveHoU.Server.NewSessionSettings.LootCategories, info.value) then
												for i = #LootReserveHoU.Server.NewSessionSettings.LootCategories, 1, -1 do
													if LootReserveHoU.Server.NewSessionSettings.LootCategories[i] == info.value then
														table.remove(LootReserveHoU.Server.NewSessionSettings.LootCategories, i);
													end
												end
											else
												table.insert(LootReserveHoU.Server.NewSessionSettings.LootCategories, info.value);
											end
											LootReserveHoU.Server.LootEdit:UpdateCategories();
											if LootReserveHoU.Server.LootEdit.Window:IsShown() then
        								ToggleDropDownMenu(nil, nil, self);
        							end
											LootReserveHoU.Server.LootEdit:UpdateLootList();
											LootReserveHoU.Server.Import:SessionSettingsUpdated();
											self:UpdateText();
										end
										local lastExpansion = nil;
										local collapsed = LootReserveHoU.Server.Settings.CollapsedExpansions[expansion];
										for id, category in LootReserveHoU:Ordered(LootReserveHoU.Data.Categories, LootReserveHoU.Data.CategorySorter) do
											if id > 0 and LootReserveHoU.Data:IsCategoryVisible(category) then
												if LootReserveHoU:GetCurrentExpansion() > 0 and category.Expansion ~= lastExpansion then
													lastExpansion = category.Expansion;
													collapsed = LootReserveHoU.Server.Settings.CollapsedExpansions[lastExpansion];
													local expansion = lastExpansion; -- Capture for closure
													UIDropDownMenu_AddButton(
													{
														text         = format("|TInterface\\Common\\spacer:4:4|t|TInterface\\Buttons\\UI-PlusMinus-Buttons:9:9:0:0:16:16:%d:%d:0:7|t|TInterface\\Common\\spacer:6:6|t|cFFFFD200%s|r", collapsed and 0 or 9, collapsed and 7 or 16, _G["EXPANSION_NAME"..lastExpansion]),
														notCheckable = true,
														checked      = not collapsed,
														func         = function(_, _, _, checked)
															LootReserveHoU.Server.Settings.CollapsedExpansions[expansion] = checked or nil;
															CloseMenus();
															ToggleDropDownMenu(nil, nil, self);
														end,
													});
												end
												if not collapsed then
													info.text             = category.Name;
													info.isNotRadio       = true;
													info.keepShownOnClick = true;
													info.value            = id;
													info.checked          = LootReserveHoU:Contains(LootReserveHoU.Server.NewSessionSettings.LootCategories, id);
													UIDropDownMenu_AddButton(info);
												end
											end
										end
									end);
								end
							</OnLoad>
						</Scripts>
					</Frame>
					<Button name="LootReserveHoUServerButtonLootEdit" parentKey="ButtonLootEdit" inherits="LootReserveHoUGlowingButtonTemplate" text="Edit Loot">
						<Size x="60" y="24" />
						<Anchors>
							<Anchor point="LEFT" relativeKey="$parent.DropDownRaid" relativePoint="RIGHT" x="-16" y="2" />
						</Anchors>
						<Scripts>
							<OnClick>
								LootReserveHoU.Server.LootEdit.Window:SetShown(not LootReserveHoU.Server.LootEdit.Window:IsShown());
							</OnClick>
						</Scripts>
					</Button>
					<EditBox parentKey="EditBoxCount" inherits="NumericInputSpinnerTemplate" autoFocus="false">
						<Size x="40" y="20" />
						<Anchors>
							<Anchor point="TOP" relativeKey="$parent.LabelCount" relativePoint="BOTTOM" />
						</Anchors>
						<Scripts>
							<OnLoad>
								self:SetMinMaxValues(0, LootReserveHoU.Constants.MAX_RESERVES);
								self:SetJustifyH("CENTER");
								self.IncrementButton:SetWidth(25);
								self.IncrementButton:SetHeight(25);
								self.DecrementButton:SetWidth(25);
								self.DecrementButton:SetHeight(25);
								self.DecrementButton:SetPoint("RIGHT", self, "LEFT", 0, 0);
								-- Hide duplicate regions
								self.Left:Hide();
								self.Middle:Hide();
								self.Right:Hide();
								-- Move inherited region
								local _, _, left = self:GetRegions();
								left:SetPoint("LEFT", self, "LEFT", 0, 0);
							</OnLoad>
							<OnTextChanged inherit="prepend">
								local count = tonumber(self:GetText());
								if count then
									if count &lt; 0 then
									  count = 0;
									elseif count > LootReserveHoU.Constants.MAX_RESERVES then
									  count = LootReserveHoU.Constants.MAX_RESERVES;
									end
									LootReserveHoU.Server.NewSessionSettings.MaxReservesPerPlayer = count;
									self:SetText(count);
								else
									LootReserveHoU.Server.NewSessionSettings.MaxReservesPerPlayer = 1;
								end
								self:SetText(LootReserveHoU.Server.NewSessionSettings.MaxReservesPerPlayer);
								LootReserveHoU.Server.MembersEdit:UpdateMembersList();
								LootReserveHoU.Server.Import:SessionSettingsUpdated();
								self:GetParent().EditBoxMultireserve:SetText(LootReserveHoU.Server.NewSessionSettings.Multireserve);
							</OnTextChanged>
							<OnEnterPressed method="ClearFocus" />
							<OnEnter>
								GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
								GameTooltip:SetText("Reserves");
								GameTooltip:AddLine("How many reserves each player may make.", HIGHLIGHT_FONT_COLOR.r, HIGHLIGHT_FONT_COLOR.g, HIGHLIGHT_FONT_COLOR.b, 1, 1);
								GameTooltip:Show();
							</OnEnter>
							<OnLeave function="GameTooltip_Hide" />
						</Scripts>
					</EditBox>
					<EditBox parentKey="EditBoxMultireserve" inherits="NumericInputSpinnerTemplate" autoFocus="false" motionScriptsWhileDisabled="true">
						<Size x="40" y="20" />
						<Anchors>
							<Anchor point="TOP" relativeKey="$parent.LabelMultireserve" relativePoint="BOTTOM" />
						</Anchors>
						<Scripts>
							<OnLoad>
								self:SetMinMaxValues(1, LootReserveHoU.Constants.MAX_MULTIRESERVES);
								self:SetJustifyH("CENTER");
								self.IncrementButton:SetWidth(25);
								self.IncrementButton:SetHeight(25);
								self.DecrementButton:SetWidth(25);
								self.DecrementButton:SetHeight(25);
								self.DecrementButton:SetPoint("RIGHT", self, "LEFT", 0, 0);
								-- Hide duplicate regions
								self.Left:Hide();
								self.Middle:Hide();
								self.Right:Hide();
								-- Move inherited region
								local _, _, left = self:GetRegions();
								left:SetPoint("LEFT", self, "LEFT", 0, 0);

								self:SetNumeric(false);
								function self:SetNumber(number)
									self:SetText(number);
								end
							</OnLoad>
							<OnTextChanged inherit="prepend">
								local count = tonumber(self:GetText());
								if count then
									if count &lt;= 0 then
									  count = 1;
									elseif count > LootReserveHoU.Constants.MAX_MULTIRESERVES then
									  count = LootReserveHoU.Constants.MAX_MULTIRESERVES;
									end
									LootReserveHoU.Server.NewSessionSettings.Multireserve = count;
								else
									LootReserveHoU.Server.NewSessionSettings.Multireserve = 1;
								end
								self:SetText(LootReserveHoU.Server.NewSessionSettings.Multireserve);
								LootReserveHoU.Server.MembersEdit:UpdateMembersList();
								LootReserveHoU.Server.Import:SessionSettingsUpdated();
							</OnTextChanged>
							<OnEnterPressed method="ClearFocus" />
							<OnEnter>
								GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
								GameTooltip:SetText("Multireserves");
								GameTooltip:AddLine("If set higher than 1, then players will be able to reserve the same item multiple times, with each additional reserve allowing them an extra /roll on the item.", HIGHLIGHT_FONT_COLOR.r, HIGHLIGHT_FONT_COLOR.g, HIGHLIGHT_FONT_COLOR.b, 1, 1);
								GameTooltip:Show();
							</OnEnter>
							<OnLeave function="GameTooltip_Hide" />
						</Scripts>
					</EditBox>
					<CheckButton parentKey="CheckButtonBlind" inherits="LootReserveHoUCheckBoxTemplate">
						<KeyValues>
							<KeyValue key="text" value="Blind" type="string" />
							<KeyValue key="tooltipText" value="Blind Reserves" type="string" />
							<KeyValue key="tooltipSubtext" value="Don't show to players what others are reserving.|n|nMassively increases the amount of addon communications, may cause delays." type="string" />
						</KeyValues>
						<Anchors>
							<Anchor point="LEFT" relativeKey="$parent.EditBoxCount" relativePoint="RIGHT" x="40" y="-1" />
						</Anchors>
						<Scripts>
							<OnClick inherit="prepend">
								LootReserveHoU.Server.NewSessionSettings.Blind = self:GetChecked();
								if LootReserveHoU.Server.CurrentSession then
									LootReserveHoU.Server.CurrentSession.Settings.Blind = self:GetChecked();
									LootReserveHoU.Comm:BroadcastSessionInfo();
									if LootReserveHoU.Server.CurrentSession.Settings.ChatFallback then
										LootReserveHoU:SendChatMessage(LootReserveHoU.Server.CurrentSession.Settings.Blind and "Blind reserves enabled, you can no longer see what other players have reserved" or "Blind reserves disabled, to see what other players reserved - whisper me: !reserves", LootReserveHoU.Server:GetChatChannel(LootReserveHoU.Constants.ChatAnnouncement.SessionBlindToggle));
									end
								end
							</OnClick>
						</Scripts>
					</CheckButton>
					<CheckButton parentKey="CheckButtonLock" inherits="LootReserveHoUCheckBoxTemplate">
						<KeyValues>
							<KeyValue key="text" value="Lock-in" type="string" />
							<KeyValue key="tooltipText" value="Reserves Lock-in" type="string" />
							<KeyValue key="tooltipSubtext" value="All reserves (made or missed) are final and cannot be changed after the host stops accepting reserves, even if the session is later resumed. New players, who haven't yet participated in reserves, will be allowed to make them.|n|nThe state of player lock-ins can be viewed and adjusted by clicking the button below." type="string" />
						</KeyValues>
						<Anchors>
							<Anchor point="TOP" relativeKey="$parent.CheckButtonBlind" relativePoint="BOTTOM" y="2" />
						</Anchors>
						<Scripts>
							<OnClick inherit="prepend">
								LootReserveHoU.Server.NewSessionSettings.Lock = self:GetChecked();
								if LootReserveHoU.Server.CurrentSession then
									LootReserveHoU.Server.CurrentSession.Settings.Lock = self:GetChecked();
									if LootReserveHoU.Server.CurrentSession.AcceptingReserves then
										LootReserveHoU.Comm:BroadcastSessionInfo();
									end
								end
								LootReserveHoU.Server.MembersEdit:UpdateMembersList();
							</OnClick>
						</Scripts>
					</CheckButton>
					<CheckButton parentKey="CheckButtonEquip" inherits="LootReserveHoUCheckBoxTemplate">
						<KeyValues>
							<KeyValue key="text" value="Usable" type="string" />
							<KeyValue key="tooltipText" value="Usable mode" type="string" />
							<KeyValue key="tooltipSubtext" value="Players will not be able to reserve items that their class is unable to use, even if the item is not Bind on Pickup (BoP).|n|nYou may override the settings for each item by customizing them in the Loot List Edit window." type="string" />
						</KeyValues>
						<Anchors>
							<Anchor point="BOTTOM" relativeKey="$parent.CheckButtonBlind" relativePoint="TOP" y="-2" />
						</Anchors>
						<Scripts>
							<OnClick inherit="prepend">
								LootReserveHoU.Server.NewSessionSettings.Equip = self:GetChecked();
								if LootReserveHoU.Server.CurrentSession then
									LootReserveHoU.Server.CurrentSession.Settings.Equip = self:GetChecked();
								end
								LootReserveHoU.Server.Import:SessionSettingsUpdated();
							</OnClick>
						</Scripts>
					</CheckButton>
					<Button name="LootReserveHoUServerButtonMembersEdit" parentKey="ButtonMembersEdit" inherits="LootReserveHoUGlowingButtonTemplate" text="Players">
						<Size x="72" y="24" />
						<Anchors>
							<Anchor point="TOPLEFT" relativeKey="$parent.CheckButtonLock" relativePoint="BOTTOMLEFT" x="2" y="0" />
						</Anchors>
						<Scripts>
							<OnClick>
								LootReserveHoU.Server.MembersEdit.Window:SetShown(not LootReserveHoU.Server.MembersEdit.Window:IsShown());
							</OnClick>
						</Scripts>
					</Button>
					<Button parentKey="ButtonResetSession" inherits="UIPanelButtonTemplate" text="Reset" hidden="true">
						<Size x="75" y="23" />
						<Anchors>
							<Anchor point="BOTTOM" y="10" />
						</Anchors>
						<Scripts>
							<OnClick>
								LootReserveHoU.Server:ResetSession();
							</OnClick>
						</Scripts>
					</Button>
					<Button parentKey="ButtonStartSession" inherits="UIPanelButtonTemplate" text="Start Session">
						<Size x="180" y="23" />
						<Anchors>
							<Anchor point="BOTTOM" relativeKey="$parent.ButtonResetSession" relativePoint="TOP" y="5" />
						</Anchors>
						<Scripts>
							<OnClick>
								if not LootReserveHoU.Server.CurrentSession then
									LootReserveHoU.Server:StartSession();
								elseif not LootReserveHoU.Server.CurrentSession.AcceptingReserves then
									LootReserveHoU.Server:ResumeSession();
								end
							</OnClick>
						</Scripts>
					</Button>
					<Button parentKey="ButtonStartReserves" inherits="UIPanelButtonTemplate" text="Start Accepting Reserves" hidden="true">
						<Size x="180" y="23" />
						<Anchors>
							<Anchor point="BOTTOM" relativeKey="$parent.ButtonResetSession" relativePoint="TOP" y="5" />
						</Anchors>
						<Scripts>
							<OnClick>
								if not LootReserveHoU.Server.CurrentSession then
									LootReserveHoU.Server:StartSession();
								elseif not LootReserveHoU.Server.CurrentSession.AcceptingReserves then
									LootReserveHoU.Server:ResumeSession();
								end
							</OnClick>
						</Scripts>
					</Button>
					<Button parentKey="ButtonStopReserves" inherits="UIPanelButtonTemplate" text="Stop Accepting Reserves" hidden="true">
						<Anchors>
							<Anchor point="TOPLEFT" relativeKey="$parent.ButtonStartSession" x="1" />
							<Anchor point="BOTTOMRIGHT" relativeKey="$parent.ButtonStartSession" x="-1" />
						</Anchors>
						<Scripts>
							<OnClick>
								LootReserveHoU.Server:StopSession();
							</OnClick>
						</Scripts>
					</Button>
					<StatusBar parentKey="Duration" inherits="LootReserveHoUDurationStatusBar" hidden="true">
						<KeyValues>
							<KeyValue key="server" value="true" type="boolean" />
						</KeyValues>
						<Size x="200" y="8" />
						<Anchors>
							<Anchor point="BOTTOM" relativeKey="$parent.ButtonStartSession" relativePoint="TOP" y="10" />
						</Anchors>
					</StatusBar>
					<Frame name="LootReserveHoUServerDropDownDuration" parentKey="DropDownDuration" inherits="UIDropDownMenuTemplate">
						<Size x="70" y="32" />
						<Anchors>
							<Anchor point="CENTER" relativeKey="$parent.Duration" relativePoint="CENTER" x="0" y="0" /> <!-- Adjusted in LootReserveHoU.Server:OnWindowLoad -->
						</Anchors>
						<Scripts>
							<OnLoad>
								self.init = function(self)
									self.init = nil;
									UIDropDownMenu_SetWidth(self, self:GetWidth());
									UIDropDownMenu_JustifyText(self, "LEFT");
									UIDropDownMenu_Initialize(self, function(frame, level, menuList)
										local info = UIDropDownMenu_CreateInfo();
										info.minWidth = self:GetWidth() - 40;
										info.func = function(info)
											LootReserveHoU.Server.NewSessionSettings.Duration = info.value;
											UIDropDownMenu_SetSelectedValue(self, info.value);
										end
										for _, time in ipairs({ 0, 10, 30, 60, 90, 120, 180, 240, 300, 600, 900, 1200, 1800, 2700, 3600 }) do
											info.text = time == 0 and "Manual" or format("%d:%02d", math.floor(time / 60), time % 60);
											info.value = time;
											UIDropDownMenu_AddButton(info);
											info.checked = false;
										end
									end);
								end
							</OnLoad>
						</Scripts>
					</Frame>
					<Frame parentKey="AddonUsers" hidden="true" enableMouse="true" frameLevel="1001">
						<Size x="30" y="12" />
						<Anchors>
							<Anchor point="BOTTOMRIGHT" x="-2" y="2" />
						</Anchors>
						<Layers>
							<Layer>
								<FontString parentKey="Text" inherits="GameFontNormalGraySmall">
									<Anchors>
										<Anchor point="RIGHT" />
									</Anchors>
									<Color r="0.5" g="0.5" b="0.5" />
								</FontString>
							</Layer>
						</Layers>
						<Scripts>
							<OnLoad>
								self.UpdateTooltip = function(self)
									GameTooltip:SetOwner(self, "ANCHOR_RIGHT");
									GameTooltip:SetText("AddOn Users");
									for _, compatibility in ipairs({ true, false }) do
										for player, compatible in LootReserveHoU:Ordered(LootReserveHoU.Server.AddonUsers) do
											if compatible == compatibility and LootReserveHoU:UnitInGroup(player) then
												GameTooltip:AddLine(format("%s%s", LootReserveHoU:ColoredPlayer(player), compatible and "" or "|cFFFF0000 (outdated)|r"));
											end
										end
									end
									GameTooltip:Show();
								end
							</OnLoad>
							<OnEnter>
								self:UpdateTooltip();
							</OnEnter>
							<OnLeave function="GameTooltip_Hide" />
						</Scripts>
					</Frame>
				</Frames>
			</Frame>
			<Frame parentKey="NoAuthority" hidden="true" enableMouse="true" frameLevel="1000">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.PanelSession" />
					<Anchor point="BOTTOMRIGHT" relativeKey="$parent.PanelSession" y="33" />
				</Anchors>
				<!--Backdrop bgFile="Interface\DialogFrame\UI-DialogBox-Background-Dark" /-->
				<Layers>
					<Layer>
						<FontString inherits="GameFontNormal" text="You must be the raid leader|nor the master looter" />
					</Layer>
				</Layers>
			</Frame>
			<Frame parentKey="AwaitingAuthority" hidden="true" enableMouse="true" frameLevel="1000">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.PanelSession" />
					<Anchor point="BOTTOMRIGHT" relativeKey="$parent.PanelSession" y="61" />
				</Anchors>
				<!--Backdrop bgFile="Interface\DialogFrame\UI-DialogBox-Background-Dark" /-->
				<Layers>
					<Layer>
						<FontString inherits="GameFontNormal" text="You have an active session|nbut aren't currently the raid|nleader or the master looter|n|nThe session will resume|nwhen you're assigned|none of these roles" />
					</Layer>
				</Layers>
			</Frame>
			<Frame parentKey="PanelReserves" parentArray="Panels" hidden="true">
				<Anchors>
					<Anchor point="TOPLEFT" x="7" y="-48" />
					<Anchor point="BOTTOMRIGHT" x="-9" y="6" />
				</Anchors>
				<Frames>
					<ScrollFrame parentKey="Scroll" inherits="LootReserveHoUScrollTemplate">
						<Anchors>
							<Anchor point="TOPLEFT" x="1" y="-1" />
							<Anchor point="BOTTOMRIGHT" x="-17" y="1" />
						</Anchors>
					</ScrollFrame>
				</Frames>
			</Frame>
			<Frame parentKey="PanelReservesLockdown" hidden="true">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.Search" relativePoint="BOTTOMLEFT" x="-3" y="-3" />
					<Anchor point="BOTTOMRIGHT" x="-9" y="6" />
				</Anchors>
				<Frames>
					<ScrollFrame parentKey="Scroll" inherits="LootReserveHoUScrollTemplate">
						<Anchors>
							<Anchor point="TOPLEFT" x="1" y="-1" />
							<Anchor point="BOTTOMRIGHT" x="-17" y="1" />
						</Anchors>
					</ScrollFrame>
				</Frames>
				<Scripts>
					<OnLoad>
						self:GetParent().Panels[2].Lockdown = self;
					</OnLoad>
				</Scripts>
			</Frame>
			<Frame parentKey="PanelRolls" parentArray="Panels" hidden="true">
				<Anchors>
					<Anchor point="TOPLEFT" x="7" y="-48" />
					<Anchor point="BOTTOMRIGHT" x="-9" y="6" />
				</Anchors>
				<Frames>
					<ScrollFrame parentKey="Scroll" inherits="LootReserveHoUScrollTemplate">
						<Anchors>
							<Anchor point="TOPLEFT" x="1" y="-1" />
							<Anchor point="BOTTOMRIGHT" x="-17" y="1" />
						</Anchors>
					</ScrollFrame>
				</Frames>
			</Frame>
			<Frame parentKey="PanelRollsLockdown" hidden="true">
				<Anchors>
					<Anchor point="TOPLEFT" relativeKey="$parent.Search" relativePoint="BOTTOMLEFT" x="-3" y="-3" />
					<Anchor point="BOTTOMRIGHT" x="-9" y="6" />
				</Anchors>
				<Frames>
					<ScrollFrame parentKey="Scroll" inherits="LootReserveHoUScrollTemplate">
						<Anchors>
							<Anchor point="TOPLEFT" x="1" y="-1" />
							<Anchor point="BOTTOMRIGHT" x="-17" y="1" />
						</Anchors>
					</ScrollFrame>
				</Frames>
				<Scripts>
					<OnLoad>
						self:GetParent().Panels[3].Lockdown = self;
					</OnLoad>
				</Scripts>
			</Frame>
		</Frames>
		<Scripts>
			<OnLoad>
				LootReserveHoU.Server:OnWindowLoad(self);
			</OnLoad>
			<OnShow>
				PlaySound(SOUNDKIT.IG_CHARACTER_INFO_OPEN);
				LootReserveHoU.Server:LoadNewSessionSettings();
				LootReserveHoU.Server:UpdateReserveList();
				LootReserveHoU.Server:UpdateRollList();
			</OnShow>
			<OnHide>
				CloseMenus();
				PlaySound(SOUNDKIT.IG_CHARACTER_INFO_CLOSE);
				LootReserveHoU.Server.RollHistoryDisplayLimit = LootReserveHoU.Server.Settings.RollHistoryDisplayLimit;
				if LootReserveHoU.Server.Settings.ShowReopenHint then
					LootReserveHoU:PrintMessage("Host window can be reopened through the minimap icon or by typing  |cFFFFD200/reserve host|r");
				end
			</OnHide>
		</Scripts>
	</Frame>
</Ui>